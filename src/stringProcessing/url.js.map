{"version":3,"sources":["../../../src/stringProcessing/url.js"],"names":["urlFromAnchorRegex","removeHash","url","split","removeQueryArgs","removeTrailingSlash","replace","addTrailingSlash","getFromAnchorTag","anchorTag","urlMatch","exec","areEqual","urlA","urlB","getHostname","parse","hostname","getProtocol","protocol","isInternalLink","host","parsedUrl","indexOf","protocolIsHttpScheme","isRelativeFragmentURL"],"mappings":";;;;;;AACA;;;;;;AADA,IAAIA,qBAAqB,wBAAzB;;;AAGA;;;;;;AAMA,SAASC,UAAT,CAAqBC,GAArB,EAA2B;AAC1B,SAAOA,IAAIC,KAAJ,CAAW,GAAX,EAAkB,CAAlB,CAAP;AACA;;AAED;;;;;;AAMA,SAASC,eAAT,CAA0BF,GAA1B,EAAgC;AAC/B,SAAOA,IAAIC,KAAJ,CAAW,GAAX,EAAkB,CAAlB,CAAP;AACA;;AAED;;;;;;AAMA,SAASE,mBAAT,CAA8BH,GAA9B,EAAoC;AACnC,SAAOA,IAAII,OAAJ,CAAa,KAAb,EAAoB,EAApB,CAAP;AACA;;AAED;;;;;;AAMA,SAASC,gBAAT,CAA2BL,GAA3B,EAAiC;AAChC,SAAOG,oBAAqBH,GAArB,IAA6B,GAApC;AACA;;AAED;;;;;;AAMA,SAASM,gBAAT,CAA2BC,SAA3B,EAAuC;AACtC,MAAIC,WAAWV,mBAAmBW,IAAnB,CAAyBF,SAAzB,CAAf;;AAEA,SAASC,aAAa,IAAf,GAAwB,EAAxB,GAA6BA,SAAU,CAAV,CAApC;AACA;;AAED;;;;;;;;AAQA,SAASE,QAAT,CAAmBC,IAAnB,EAAyBC,IAAzB,EAAgC;AAC/B;AACAD,SAAOT,gBAAiBH,WAAYY,IAAZ,CAAjB,CAAP;AACAC,SAAOV,gBAAiBH,WAAYa,IAAZ,CAAjB,CAAP;;AAEA,SAAOP,iBAAkBM,IAAlB,MAA6BN,iBAAkBO,IAAlB,CAApC;AACA;;AAED;;;;;;AAMA,SAASC,WAAT,CAAsBb,GAAtB,EAA4B;AAC3BA,QAAM,cAAWc,KAAX,CAAkBd,GAAlB,CAAN;;AAEA,SAAOA,IAAIe,QAAX;AACA;;AAED;;;;;;;;AAQA,SAASC,WAAT,CAAsBhB,GAAtB,EAA4B;AAC3B,SAAO,cAAWc,KAAX,CAAkBd,GAAlB,EAAwBiB,QAA/B;AACA;;AAED;;;;;;;;AAQA,SAASC,cAAT,CAAyBlB,GAAzB,EAA8BmB,IAA9B,EAAqC;AACpC,MAAMC,YAAY,cAAWN,KAAX,CAAkBd,GAAlB,EAAuB,KAAvB,EAA8B,IAA9B,CAAlB;AACA;AACA,MAAKA,IAAIqB,OAAJ,CAAa,IAAb,MAAwB,CAAC,CAAzB,IAA8BrB,IAAIqB,OAAJ,CAAa,GAAb,MAAuB,CAA1D,EAA8D;AAC7D,WAAO,IAAP;AACA;;AAED;AACA,MAAKrB,IAAIqB,OAAJ,CAAa,GAAb,MAAuB,CAA5B,EAAgC;AAC/B,WAAO,KAAP;AACA;;AAED;AACA,MAAK,CAAED,UAAUD,IAAjB,EAAwB;AACvB,WAAO,IAAP;AACA;;AAED,SAAOC,UAAUD,IAAV,KAAmBA,IAA1B;AACA;;AAED;;;;;;;AAOA,SAASG,oBAAT,CAA+BL,QAA/B,EAA0C;AACzC,MAAK,CAAEA,QAAP,EAAkB;AACjB,WAAO,KAAP;AACA;;AAED,SAASA,aAAa,OAAb,IAAwBA,aAAa,QAA9C;AACA;;AAED;;;;;;;AAOA,SAASM,qBAAT,CAAgCvB,GAAhC,EAAsC;AACrC,SAAOA,IAAIqB,OAAJ,CAAa,GAAb,MAAuB,CAA9B;AACA;;kBAEc;AACdtB,cAAYA,UADE;AAEdG,mBAAiBA,eAFH;AAGdC,uBAAqBA,mBAHP;AAIdE,oBAAkBA,gBAJJ;AAKdC,oBAAkBA,gBALJ;AAMdI,YAAUA,QANI;AAOdG,eAAaA,WAPC;AAQdG,eAAaA,WARC;AASdE,kBAAgBA,cATF;AAUdI,wBAAsBA,oBAVR;AAWdC,yBAAuBA;AAXT,C","file":"url.js","sourcesContent":["var urlFromAnchorRegex = /href=([\"'])([^\"']+)\\1/i;\nimport urlMethods from \"url\";\n\n/**\n * Removes a hash from a URL, assumes a well formed URL.\n *\n * @param {string} url The URL to remove a hash from.\n * @returns {string} The URL without the hash.\n */\nfunction removeHash( url ) {\n\treturn url.split( \"#\" )[ 0 ];\n}\n\n/**\n * Removes all query args from a URL, assumes a well formed URL.\n *\n * @param {string} url The URL to remove the query args from.\n * @returns {string} The URL without the query args.\n */\nfunction removeQueryArgs( url ) {\n\treturn url.split( \"?\" )[ 0 ];\n}\n\n/**\n * Removes the trailing slash of a URL.\n *\n * @param {string} url The URL to remove the trailing slash from.\n * @returns {string} A URL without a trailing slash.\n */\nfunction removeTrailingSlash( url ) {\n\treturn url.replace( /\\/$/, \"\" );\n}\n\n/**\n * Adds a trailing slash to a URL if it is not present.\n *\n * @param {string} url The URL to add a trailing slash to.\n * @returns {string} A URL with a trailing slash.\n */\nfunction addTrailingSlash( url ) {\n\treturn removeTrailingSlash( url ) + \"/\";\n}\n\n/**\n * Retrieves the URL from an anchor tag.\n *\n * @param {string} anchorTag An anchor tag.\n * @returns {string} The URL in the anchor tag.\n */\nfunction getFromAnchorTag( anchorTag ) {\n\tvar urlMatch = urlFromAnchorRegex.exec( anchorTag );\n\n\treturn ( urlMatch === null ) ? \"\" : urlMatch[ 2 ];\n}\n\n/**\n * Returns whether or not the given URLs are equal.\n *\n * @param {string} urlA The first URL to compare.\n * @param {string} urlB The second URL to compare.\n *\n * @returns {boolean} Whether or not the given URLs are equal.\n */\nfunction areEqual( urlA, urlB ) {\n\t// Make sure we are comparing URLs without query arguments and hashes.\n\turlA = removeQueryArgs( removeHash( urlA ) );\n\turlB = removeQueryArgs( removeHash( urlB ) );\n\n\treturn addTrailingSlash( urlA ) === addTrailingSlash( urlB );\n}\n\n/**\n * Returns the domain name of a URL.\n *\n * @param {string} url The URL to retrieve the domain name of.\n * @returns {string} The domain name of the URL.\n */\nfunction getHostname( url ) {\n\turl = urlMethods.parse( url );\n\n\treturn url.hostname;\n}\n\n/**\n * Returns the protocol of a URL.\n *\n * Note that the colon (http:) is also part of the protocol, conform to node's url.parse api.\n *\n * @param {string} url The URL to retrieve the protocol of.\n * @returns {string|null} The protocol of the URL or null if no protocol is present.\n */\nfunction getProtocol( url ) {\n\treturn urlMethods.parse( url ).protocol;\n}\n\n/**\n * Determine whether a URL is internal.\n *\n * @param {string} url The URL to test.\n * @param {string} host The current host.\n *\n * @returns {boolean} Whether or not the URL is internal.\n */\nfunction isInternalLink( url, host ) {\n\tconst parsedUrl = urlMethods.parse( url, false, true );\n\t// Check if the URL starts with a single slash.\n\tif ( url.indexOf( \"//\" ) === -1 && url.indexOf( \"/\" ) === 0 ) {\n\t\treturn true;\n\t}\n\n\t// Check if the URL starts with a # indicating a fragment.\n\tif ( url.indexOf( \"#\" ) === 0 ) {\n\t\treturn false;\n\t}\n\n\t// No host indicates an internal link.\n\tif ( ! parsedUrl.host ) {\n\t\treturn true;\n\t}\n\n\treturn parsedUrl.host === host;\n}\n\n/**\n * Checks whether the protocol is either HTTP: or HTTPS:.\n *\n * @param {string} protocol The protocol to test.\n *\n * @returns {boolean} Whether the protocol is http(s):.\n */\nfunction protocolIsHttpScheme( protocol ) {\n\tif ( ! protocol ) {\n\t\treturn false;\n\t}\n\n\treturn ( protocol === \"http:\" || protocol === \"https:\" );\n}\n\n/**\n * Determines whether the link is a relative fragment URL.\n *\n * @param {string} url The URL to test.\n *\n * @returns {boolean} Whether the link is a relative fragment URL.\n */\nfunction isRelativeFragmentURL( url ) {\n\treturn url.indexOf( \"#\" ) === 0;\n}\n\nexport default {\n\tremoveHash: removeHash,\n\tremoveQueryArgs: removeQueryArgs,\n\tremoveTrailingSlash: removeTrailingSlash,\n\taddTrailingSlash: addTrailingSlash,\n\tgetFromAnchorTag: getFromAnchorTag,\n\tareEqual: areEqual,\n\tgetHostname: getHostname,\n\tgetProtocol: getProtocol,\n\tisInternalLink: isInternalLink,\n\tprotocolIsHttpScheme: protocolIsHttpScheme,\n\tisRelativeFragmentURL: isRelativeFragmentURL,\n};\n"]}