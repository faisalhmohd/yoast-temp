{"version":3,"sources":["../../../src/stringProcessing/SentenceTokenizer.js"],"names":["fullStop","sentenceDelimiters","fullStopRegex","RegExp","sentenceDelimiterRegex","sentenceRegex","smallerThanContentRegex","htmlStartRegex","htmlEndRegex","blockStartRegex","blockEndRegex","sentenceEndRegex","SentenceTokenizer","character","parseInt","htmlTag","test","text","replace","toLocaleLowerCase","nextTokens","next","src","removeDuplicateWhitespace","sentenceBeginning","isCapitalLetter","isNumber","isQuotation","isPunctuation","isSmallerThanSign","token","type","tokenSentences","currentSentence","localText","substring","tokenizerResult","createTokenizer","tokenize","tokenizer","localSentences","getSentencesFromTokens","tokens","isValidSentenceBeginning","push","length","shift","lastSentence","pop","forEach","sentence","match","addRule","onText","end","e","console","error","tokenizer2","tokenArray","trimSentences","nextSentenceStart","sliced","firstToken","lastToken","slice","i","hasNextSentence","nextCharacters","tokenizeResults","nextToken","secondToNextToken","isBreakTag","tokenizeSmallerThanContent","getNextTwoCharacters","isSentenceStart","trim"],"mappings":"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","file":"SentenceTokenizer.js","sourcesContent":["import { map } from \"lodash-es\";\nimport { isUndefined } from \"lodash-es\";\nimport { isNaN } from \"lodash-es\";\n\nimport core from \"tokenizer2/core\";\n\nimport { normalize as normalizeQuotes } from \"../stringProcessing/quotes.js\";\n\n// All characters that indicate a sentence delimiter.\nconst fullStop = \".\";\n// The \\u2026 character is an ellipsis\nconst sentenceDelimiters = \"?!;\\u2026\";\n\nconst fullStopRegex = new RegExp( \"^[\" + fullStop + \"]$\" );\nconst sentenceDelimiterRegex = new RegExp( \"^[\" + sentenceDelimiters + \"]$\" );\nconst sentenceRegex = new RegExp( \"^[^\" + fullStop + sentenceDelimiters + \"<\\\\(\\\\)\\\\[\\\\]]+$\" );\nconst smallerThanContentRegex = /^<[^><]*$/;\nconst htmlStartRegex = /^<([^>\\s/]+)[^>]*>$/mi;\nconst htmlEndRegex = /^<\\/([^>\\s]+)[^>]*>$/mi;\n\nconst blockStartRegex = /^\\s*[[({]\\s*$/;\nconst blockEndRegex = /^\\s*[\\])}]\\s*$/;\n\nconst sentenceEndRegex = new RegExp( \"[\" + fullStop + sentenceDelimiters + \"]$\" );\n\n/**\n * Class for tokenizing a (html) text into sentences.\n */\nexport default class SentenceTokenizer {\n\t/**\n\t * Returns whether or not a certain character is a number.\n\t *\n\t * @param {string} character The character to check.\n\t * @returns {boolean} Whether or not the character is a capital letter.\n\t */\n\tisNumber( character ) {\n\t\treturn ! isNaN( parseInt( character, 10 ) );\n\t}\n\n\t/**\n\t * Returns whether or not a given HTML tag is a break tag.\n\t *\n\t * @param {string} htmlTag The HTML tag to check.\n\t * @returns {boolean} Whether or not the given HTML tag is a break tag.\n\t */\n\tisBreakTag( htmlTag ) {\n\t\treturn /<br/.test( htmlTag );\n\t}\n\n\t/**\n\t * Returns whether or not a given character is quotation mark.\n\t *\n\t * @param {string} character The character to check.\n\t * @returns {boolean} Whether or not the given character is a quotation mark.\n\t */\n\tisQuotation( character ) {\n\t\tcharacter = normalizeQuotes( character );\n\n\t\treturn \"'\" === character ||\n\t\t\t\"\\\"\" === character;\n\t}\n\n\t/**\n\t * Returns whether or not a given character is a punctuation mark that can be at the beginning\n\t * of a sentence, like ¿ and ¡ used in Spanish.\n\t *\n\t * @param {string} character The character to check.\n\t * @returns {boolean} Whether or not the given character is a punctuation mark.\n\t */\n\tisPunctuation( character ) {\n\t\treturn \"¿\" === character ||\n\t\t\t\"¡\" === character;\n\t}\n\n\t/**\n\t * Removes duplicate whitespace from a given text.\n\t *\n\t * @param {string} text The text with duplicate whitespace.\n\t * @returns {string} The text without duplicate whitespace.\n\t */\n\tremoveDuplicateWhitespace( text ) {\n\t\treturn text.replace( /\\s+/, \" \" );\n\t}\n\n\t/**\n\t * Returns whether or not a certain character is a capital letter.\n\t *\n\t * @param {string} character The character to check.\n\t * @returns {boolean} Whether or not the character is a capital letter.\n\t */\n\tisCapitalLetter( character ) {\n\t\treturn character !== character.toLocaleLowerCase();\n\t}\n\n\t/**\n\t * Checks whether the given character is a smaller than sign.\n\t *\n\t * This function is used to make sure that tokenizing the content after\n\t * the smaller than sign works as expected.\n\t * E.g. 'A sentence. < Hello world!' = ['A sentence.', '< Hello world!'].\n\t *\n\t * @param {string} character The character to check.\n\t * @returns {boolean} Whether the character is a smaller than sign ('<') or not.\n\t */\n\tisSmallerThanSign( character ) {\n\t\treturn character === \"<\";\n\t}\n\n\t/**\n\t * Retrieves the next two characters from an array with the two next tokens.\n\t *\n\t * @param {Array} nextTokens The two next tokens. Might be undefined.\n\t * @returns {string} The next two characters.\n\t */\n\tgetNextTwoCharacters( nextTokens ) {\n\t\tlet next = \"\";\n\n\t\tif ( ! isUndefined( nextTokens[ 0 ] ) ) {\n\t\t\tnext += nextTokens[ 0 ].src;\n\t\t}\n\n\t\tif ( ! isUndefined( nextTokens[ 1 ] ) ) {\n\t\t\tnext += nextTokens[ 1 ].src;\n\t\t}\n\n\t\tnext = this.removeDuplicateWhitespace( next );\n\n\t\treturn next;\n\t}\n\n\t/**\n\t * Checks if the sentenceBeginning beginning is a valid beginning.\n\t *\n\t * @param {string} sentenceBeginning The beginning of the sentence to validate.\n\t * @returns {boolean} Returns true if it is a valid beginning, false if it is not.\n\t */\n\tisValidSentenceBeginning( sentenceBeginning ) {\n\t\treturn (\n\t\t\tthis.isCapitalLetter( sentenceBeginning ) ||\n\t\t\tthis.isNumber( sentenceBeginning ) ||\n\t\t\tthis.isQuotation( sentenceBeginning ) ||\n\t\t\tthis.isPunctuation( sentenceBeginning ) ||\n\t\t\tthis.isSmallerThanSign( sentenceBeginning )\n\t\t);\n\t}\n\n\t/**\n\t * Checks if the token is a valid sentence ending.\n\t *\n\t * @param {Object} token The token to validate.\n\t * @returns {boolean} Returns true if the token is valid ending, false if it is not.\n\t */\n\tisSentenceStart( token ) {\n\t\treturn ( ! isUndefined( token ) && (\n\t\t\t\"html-start\" === token.type ||\n\t\t\t\"html-end\" === token.type ||\n\t\t\t\"block-start\" === token.type\n\t\t) );\n\t}\n\n\t/**\n\t * Tokens that represent a '<', followed by content until it enters another '<' or '>'\n\t * gets another pass by the tokenizer.\n\t *\n\t * @param {Object} token A token of type 'smaller-than-sign-content'.\n\t * @param {string[]} tokenSentences The current array of found sentences. Sentences may get added by this method.\n\t * @param {string} currentSentence The current sentence. Sentence parts may get appended by this method.\n\t * @returns {{tokenSentences, currentSentence}} The found sentences and the current sentence, appended when necessary.\n\t */\n\ttokenizeSmallerThanContent( token, tokenSentences, currentSentence ) {\n\t\t/*\n\t\t\tRemove the '<' from the text, to avoid matching this rule\n\t\t\trecursively again and again.\n\t\t\tWe add it again later on.\n\t\t*/\n\t\tconst localText = token.src.substring( 1 );\n\n\t\t// Tokenize the current smaller-than-content token without the first '<'.\n\t\tconst tokenizerResult = this.createTokenizer();\n\t\tthis.tokenize( tokenizerResult.tokenizer, localText );\n\t\tconst localSentences = this.getSentencesFromTokens( tokenizerResult.tokens, false );\n\n\t\tlocalSentences[ 0 ] = isUndefined( localSentences[ 0 ] ) ? \"<\" : \"<\" + localSentences[ 0 ];\n\n\t\t/*\n\t\t * When the first sentence has a valid sentence beginning.\n\t\t * Add the currently build sentence to the sentences.\n\t\t * Start building the next sentence.\n\t\t */\n\t\tif ( this.isValidSentenceBeginning( localSentences[ 0 ] ) ) {\n\t\t\ttokenSentences.push( currentSentence );\n\t\t\tcurrentSentence = \"\";\n\t\t}\n\t\tcurrentSentence += localSentences[ 0 ];\n\n\t\tif ( localSentences.length > 1 ) {\n\t\t\t/*\n\t\t\t\tThere is a new sentence after the first,\n\t\t\t\tadd and reset the current sentence.\n\t\t\t */\n\t\t\ttokenSentences.push( currentSentence );\n\t\t\tcurrentSentence = \"\";\n\n\t\t\t// Remove the first sentence (we do not need to add it again).\n\t\t\tlocalSentences.shift();\n\t\t\t// Last sentence gets special treatment.\n\t\t\tconst lastSentence = localSentences.pop();\n\n\t\t\t// Add the remaining found sentences.\n\t\t\tlocalSentences.forEach( sentence => {\n\t\t\t\ttokenSentences.push( sentence );\n\t\t\t} );\n\n\t\t\t// Check if the last sentence has a valid sentence ending.\n\t\t\tif ( lastSentence.match( sentenceEndRegex ) ) {\n\t\t\t\t// If so, add it as a sentence.\n\t\t\t\ttokenSentences.push( lastSentence );\n\t\t\t} else {\n\t\t\t\t// If not, start making a new one.\n\t\t\t\tcurrentSentence = lastSentence;\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\ttokenSentences,\n\t\t\tcurrentSentence,\n\t\t};\n\t}\n\n\t/**\n\t * Creates a tokenizer.\n\t *\n\t * @returns {Object} The tokenizer and the tokens.\n\t */\n\tcreateTokenizer() {\n\t\tconst tokens = [];\n\t\tconst tokenizer = core( function( token ) {\n\t\t\ttokens.push( token );\n\t\t} );\n\n\t\ttokenizer.addRule( fullStopRegex, \"full-stop\" );\n\t\ttokenizer.addRule( smallerThanContentRegex, \"smaller-than-sign-content\" );\n\t\ttokenizer.addRule( htmlStartRegex, \"html-start\" );\n\t\ttokenizer.addRule( htmlEndRegex, \"html-end\" );\n\t\ttokenizer.addRule( blockStartRegex, \"block-start\" );\n\t\ttokenizer.addRule( blockEndRegex, \"block-end\" );\n\t\ttokenizer.addRule( sentenceDelimiterRegex, \"sentence-delimiter\" );\n\t\ttokenizer.addRule( sentenceRegex, \"sentence\" );\n\n\t\treturn {\n\t\t\ttokenizer,\n\t\t\ttokens,\n\t\t};\n\t}\n\n\t/**\n\t * Tokenizes the given text using the given tokenizer.\n\t *\n\t * @param {Object} tokenizer The tokenizer to use.\n\t * @param {string} text The text to tokenize.\n\t * @returns {void}\n\t */\n\ttokenize( tokenizer, text ) {\n\t\ttokenizer.onText( text );\n\n\t\ttry {\n\t\t\ttokenizer.end();\n\t\t} catch ( e ) {\n\t\t\tconsole.error( \"Tokenizer end error:\", e, e.tokenizer2 );\n\t\t}\n\t}\n\n\t/**\n\t * Returns an array of sentences for a given array of tokens, assumes that the text has already been split into blocks.\n\t *\n\t * @param {Object[]} tokenArray The tokens from the sentence tokenizer.\n\t * @param {boolean} [trimSentences=true] Whether to trim the sentences at the end or not.\n\t *\n\t * @returns {string[]} A list of sentences.\n\t */\n\tgetSentencesFromTokens( tokenArray, trimSentences = true ) {\n\t\tlet tokenSentences = [], currentSentence = \"\", nextSentenceStart, sliced;\n\n\t\t// Drop the first and last HTML tag if both are present.\n\t\tdo {\n\t\t\tsliced = false;\n\t\t\tconst firstToken = tokenArray[ 0 ];\n\t\t\tconst lastToken = tokenArray[ tokenArray.length - 1 ];\n\n\t\t\tif ( firstToken && lastToken && firstToken.type === \"html-start\" && lastToken.type === \"html-end\" ) {\n\t\t\t\ttokenArray = tokenArray.slice( 1, tokenArray.length - 1 );\n\n\t\t\t\tsliced = true;\n\t\t\t}\n\t\t} while ( sliced && tokenArray.length > 1 );\n\n\t\ttokenArray.forEach( ( token, i ) => {\n\t\t\tlet hasNextSentence, nextCharacters, tokenizeResults;\n\t\t\tconst nextToken = tokenArray[ i + 1 ];\n\t\t\tconst secondToNextToken = tokenArray[ i + 2 ];\n\n\t\t\tswitch ( token.type ) {\n\t\t\t\tcase \"html-start\":\n\t\t\t\tcase \"html-end\":\n\t\t\t\t\tif ( this.isBreakTag( token.src ) ) {\n\t\t\t\t\t\ttokenSentences.push( currentSentence );\n\t\t\t\t\t\tcurrentSentence = \"\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurrentSentence += token.src;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"smaller-than-sign-content\":\n\t\t\t\t\ttokenizeResults = this.tokenizeSmallerThanContent( token, tokenSentences, currentSentence );\n\t\t\t\t\ttokenSentences = tokenizeResults.tokenSentences;\n\t\t\t\t\tcurrentSentence = tokenizeResults.currentSentence;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sentence\":\n\t\t\t\t\tcurrentSentence += token.src;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sentence-delimiter\":\n\t\t\t\t\tcurrentSentence += token.src;\n\n\t\t\t\t\tif ( ! isUndefined( nextToken ) && \"block-end\" !== nextToken.type && \"sentence-delimiter\" !== nextToken.type ) {\n\t\t\t\t\t\ttokenSentences.push( currentSentence );\n\t\t\t\t\t\tcurrentSentence = \"\";\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"full-stop\":\n\t\t\t\t\tcurrentSentence += token.src;\n\n\t\t\t\t\tnextCharacters = this.getNextTwoCharacters( [ nextToken, secondToNextToken ] );\n\n\t\t\t\t\t// For a new sentence we need to check the next two characters.\n\t\t\t\t\thasNextSentence = nextCharacters.length >= 2;\n\t\t\t\t\tnextSentenceStart = hasNextSentence ? nextCharacters[ 1 ] : \"\";\n\t\t\t\t\t// If the next character is a number, never split. For example: IPv4-numbers.\n\t\t\t\t\tif ( hasNextSentence && this.isNumber( nextCharacters[ 0 ] ) ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// Only split on sentence delimiters when the next sentence looks like the start of a sentence.\n\t\t\t\t\tif ( ( hasNextSentence && this.isValidSentenceBeginning( nextSentenceStart ) ) || this.isSentenceStart( nextToken ) ) {\n\t\t\t\t\t\ttokenSentences.push( currentSentence );\n\t\t\t\t\t\tcurrentSentence = \"\";\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"block-start\":\n\t\t\t\t\tcurrentSentence += token.src;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"block-end\":\n\t\t\t\t\tcurrentSentence += token.src;\n\n\t\t\t\t\tnextCharacters = this.getNextTwoCharacters( [ nextToken, secondToNextToken ] );\n\n\t\t\t\t\t// For a new sentence we need to check the next two characters.\n\t\t\t\t\thasNextSentence = nextCharacters.length >= 2;\n\t\t\t\t\tnextSentenceStart = hasNextSentence ? nextCharacters[ 0 ] : \"\";\n\t\t\t\t\t// If the next character is a number, never split. For example: IPv4-numbers.\n\t\t\t\t\tif ( hasNextSentence && this.isNumber( nextCharacters[ 0 ] ) ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ( hasNextSentence && this.isValidSentenceBeginning( nextSentenceStart ) ) || this.isSentenceStart( nextToken ) ) {\n\t\t\t\t\t\ttokenSentences.push( currentSentence );\n\t\t\t\t\t\tcurrentSentence = \"\";\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} );\n\n\t\tif ( \"\" !== currentSentence ) {\n\t\t\ttokenSentences.push( currentSentence );\n\t\t}\n\n\t\tif ( trimSentences ) {\n\t\t\ttokenSentences = map( tokenSentences, function( sentence ) {\n\t\t\t\treturn sentence.trim();\n\t\t\t} );\n\t\t}\n\n\t\treturn tokenSentences;\n\t}\n}\n"]}