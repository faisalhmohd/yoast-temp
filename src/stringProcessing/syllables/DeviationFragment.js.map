{"version":3,"sources":["../../../../src/stringProcessing/syllables/DeviationFragment.js"],"names":["DeviationFragment","options","_location","location","_fragment","word","_syllables","syllables","_regex","_options","prototype","createRegex","regexString","fragment","notFollowedBy","join","alsoFollowedBy","RegExp","getRegex","occursIn","regex","test","removeFrom","replace","getSyllables"],"mappings":";;;;;;AAAA;;AAGA;;;;;;;;;;;;AAYA,SAASA,iBAAT,CAA4BC,OAA5B,EAAsC;AACrC,MAAKC,SAAL,GAAiBD,QAAQE,QAAzB;AACA,MAAKC,SAAL,GAAiBH,QAAQI,IAAzB;AACA,MAAKC,UAAL,GAAkBL,QAAQM,SAA1B;AACA,MAAKC,MAAL,GAAc,IAAd;;AAEA,MAAKC,QAAL,GAAgB,oBAAMR,OAAN,EAAe,CAAE,eAAF,EAAmB,gBAAnB,CAAf,CAAhB;AACA;;AAED;;;;;AAKAD,kBAAkBU,SAAlB,CAA4BC,WAA5B,GAA0C,YAAW;AACpD,KAAIC,cAAc,EAAlB;AACA,KAAIX,UAAU,KAAKQ,QAAnB;;AAEA,KAAII,WAAW,KAAKT,SAApB;;AAEA,KAAK,CAAE,2BAAaH,QAAQa,aAArB,CAAP,EAA8C;AAC7CD,cAAY,SAASZ,QAAQa,aAAR,CAAsBC,IAAtB,CAA4B,EAA5B,CAAT,GAA4C,IAAxD;AACA;;AAED,KAAK,CAAE,2BAAad,QAAQe,cAArB,CAAP,EAA+C;AAC9CH,cAAY,MAAMZ,QAAQe,cAAR,CAAuBD,IAAvB,CAA6B,EAA7B,CAAN,GAA0C,IAAtD;AACA;;AAED,SAAS,KAAKb,SAAd;AACC,OAAK,aAAL;AACCU,iBAAc,MAAMC,QAApB;AACA;;AAED,OAAK,OAAL;AACCD,iBAAcC,WAAW,GAAzB;AACA;;AAED,OAAK,kBAAL;AACCD,iBAAc,OAAOC,QAAP,GAAkB,KAAlB,GAA0BA,QAA1B,GAAqC,IAAnD;AACA;;AAED;AACCD,iBAAcC,QAAd;AACA;AAfF;;AAkBA,MAAKL,MAAL,GAAc,IAAIS,MAAJ,CAAYL,WAAZ,CAAd;AACA,CAjCD;;AAmCA;;;;;AAKAZ,kBAAkBU,SAAlB,CAA4BQ,QAA5B,GAAuC,YAAW;AACjD,KAAK,SAAS,KAAKV,MAAnB,EAA4B;AAC3B,OAAKG,WAAL;AACA;;AAED,QAAO,KAAKH,MAAZ;AACA,CAND;;AAQA;;;;;;AAMAR,kBAAkBU,SAAlB,CAA4BS,QAA5B,GAAuC,UAAUd,IAAV,EAAiB;AACvD,KAAIe,QAAQ,KAAKF,QAAL,EAAZ;;AAEA,QAAOE,MAAMC,IAAN,CAAYhB,IAAZ,CAAP;AACA,CAJD;;AAMA;;;;;;AAMAL,kBAAkBU,SAAlB,CAA4BY,UAA5B,GAAyC,UAAUjB,IAAV,EAAiB;AACzD;AACA,QAAOA,KAAKkB,OAAL,CAAc,KAAKnB,SAAnB,EAA8B,GAA9B,CAAP;AACA,CAHD;;AAKA;;;;;AAKAJ,kBAAkBU,SAAlB,CAA4Bc,YAA5B,GAA2C,YAAW;AACrD,QAAO,KAAKlB,UAAZ;AACA,CAFD;;kBAIeN,iB","file":"DeviationFragment.js","sourcesContent":["import { isUndefined } from \"lodash-es\";\nimport { pick } from \"lodash-es\";\n\n/**\n * Represents a partial deviation when counting syllables\n *\n * @param {Object} options Extra options about how to match this fragment.\n * @param {string} options.location The location in the word where this deviation can occur.\n * @param {string} options.word The actual string that should be counted differently.\n * @param {number} options.syllables The amount of syllables this fragment has.\n * @param {string[]} [options.notFollowedBy] A list of characters that this fragment shouldn't be followed with.\n * @param {string[]} [options.alsoFollowedBy] A list of characters that this fragment could be followed with.\n *\n * @constructor\n */\nfunction DeviationFragment( options ) {\n\tthis._location = options.location;\n\tthis._fragment = options.word;\n\tthis._syllables = options.syllables;\n\tthis._regex = null;\n\n\tthis._options = pick( options, [ \"notFollowedBy\", \"alsoFollowedBy\" ] );\n}\n\n/**\n * Creates a regex that matches this fragment inside a word.\n *\n * @returns {void}\n */\nDeviationFragment.prototype.createRegex = function() {\n\tvar regexString = \"\";\n\tvar options = this._options;\n\n\tvar fragment = this._fragment;\n\n\tif ( ! isUndefined( options.notFollowedBy ) ) {\n\t\tfragment += \"(?![\" + options.notFollowedBy.join( \"\" ) + \"])\";\n\t}\n\n\tif ( ! isUndefined( options.alsoFollowedBy ) ) {\n\t\tfragment += \"[\" + options.alsoFollowedBy.join( \"\" ) + \"]?\";\n\t}\n\n\tswitch ( this._location ) {\n\t\tcase \"atBeginning\":\n\t\t\tregexString = \"^\" + fragment;\n\t\t\tbreak;\n\n\t\tcase \"atEnd\":\n\t\t\tregexString = fragment + \"$\";\n\t\t\tbreak;\n\n\t\tcase \"atBeginningOrEnd\":\n\t\t\tregexString = \"(^\" + fragment + \")|(\" + fragment + \"$)\";\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tregexString = fragment;\n\t\t\tbreak;\n\t}\n\n\tthis._regex = new RegExp( regexString );\n};\n\n/**\n * Returns the regex that matches this fragment inside a word.\n *\n * @returns {RegExp} The regexp that matches this fragment.\n */\nDeviationFragment.prototype.getRegex = function() {\n\tif ( null === this._regex ) {\n\t\tthis.createRegex();\n\t}\n\n\treturn this._regex;\n};\n\n/**\n * Returns whether or not this fragment occurs in a word.\n *\n * @param {string} word The word to match the fragment in.\n * @returns {boolean} Whether or not this fragment occurs in a word.\n */\nDeviationFragment.prototype.occursIn = function( word ) {\n\tvar regex = this.getRegex();\n\n\treturn regex.test( word );\n};\n\n/**\n * Removes this fragment from the given word.\n *\n * @param {string} word The word to remove this fragment from.\n * @returns {string} The modified word.\n */\nDeviationFragment.prototype.removeFrom = function( word ) {\n\t// Replace by a space to keep the remaining parts separated.\n\treturn word.replace( this._fragment, \" \" );\n};\n\n/**\n * Returns the amount of syllables for this fragment.\n *\n * @returns {number} The amount of syllables for this fragment.\n */\nDeviationFragment.prototype.getSyllables = function() {\n\treturn this._syllables;\n};\n\nexport default DeviationFragment;\n"]}