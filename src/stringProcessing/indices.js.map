{"version":3,"sources":["../../../src/stringProcessing/indices.js"],"names":["getIndicesByWord","word","text","startIndex","searchStringLength","length","index","indices","indexOf","isPreviousCharacterWordBoundary","isNextCharacterWordBoundary","push","match","getIndicesByWordList","words","matchedWords","concat","sortIndices","sort","a","b","filterIndices","filtered","i","getIndicesByWordListSorted"],"mappings":"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","file":"indices.js","sourcesContent":["import { isUndefined } from \"lodash-es\";\nimport { forEach } from \"lodash-es\";\nimport stripSpaces from \"../stringProcessing/stripSpaces.js\";\nimport { isWordInSentence as matchWordInSentence } from \"../stringProcessing/matchWordInSentence.js\";\nimport { characterInBoundary } from \"../stringProcessing/matchWordInSentence.js\";\n\n/**\n * Returns the indices of a string in a text. If it is found multiple times, it will return multiple indices.\n *\n * @param {string} word The word to find in the text.\n * @param {string} text The text to check for the given word.\n * @returns {Array} All indices found.\n */\nfunction getIndicesByWord( word, text ) {\n\tvar startIndex = 0;\n\tvar searchStringLength = word.length;\n\tvar index, indices = [];\n\twhile ( ( index = text.indexOf( word, startIndex ) ) > -1 ) {\n\t\t// Check if the previous and next character are word boundaries to determine if a complete word was detected\n\t\tvar isPreviousCharacterWordBoundary = characterInBoundary( text[ index - 1 ] ) || index === 0;\n\n\t\tvar isNextCharacterWordBoundary = characterInBoundary( text[ index + searchStringLength ] ) || ( text.length === index + searchStringLength );\n\n\t\tif ( isPreviousCharacterWordBoundary && isNextCharacterWordBoundary ) {\n\t\t\tindices.push(\n\t\t\t\t{\n\t\t\t\t\tindex: index,\n\t\t\t\t\tmatch: word,\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t\tstartIndex = index + searchStringLength;\n\t}\n\treturn indices;\n}\n\n/**\n * Matches string with an array, returns the word and the index it was found on.\n *\n * @param {Array} words The array with strings to match.\n * @param {string} text The text to match the strings from the array to.\n * @returns {Array} The array with words, containing the index of the match and the matched string.\n * Returns an empty array if none are found.\n */\nvar getIndicesByWordList = function( words, text ) {\n\tvar matchedWords = [];\n\n\tforEach( words, function( word ) {\n\t\tword = stripSpaces( word );\n\t\tif ( ! matchWordInSentence( word, text ) ) {\n\t\t\treturn;\n\t\t}\n\t\tmatchedWords = matchedWords.concat( getIndicesByWord( word, text ) );\n\t} );\n\treturn matchedWords;\n};\n\n/**\n * Sorts the array on the index property of each entry.\n *\n * @param {Array} indices The array with indices.\n * @returns {Array} The sorted array with indices.\n */\nvar sortIndices = function( indices ) {\n\treturn indices.sort( function( a, b ) {\n\t\treturn ( a.index > b.index );\n\t} );\n};\n\n/**\n * Filters duplicate entries if the indices overlap.\n *\n * @param {Array} indices The array with indices to be filtered.\n * @returns {Array} The filtered array.\n */\nvar filterIndices = function( indices ) {\n\tindices = sortIndices( indices );\n\tvar filtered = [];\n\tfor ( var i = 0; i < indices.length; i++ ) {\n\t\t// If the next index is within the range of the current index and the length of the word, remove it\n\t\t// This makes sure we don't match combinations twice, like \"even though\" and \"though\".\n\t\tif ( ! isUndefined( indices[ i + 1 ] ) && indices[ i + 1 ].index < indices[ i ].index + indices[ i ].match.length ) {\n\t\t\tfiltered.push( indices[ i ] );\n\n\t\t\t// Adds 1 to i, so we skip the next index that is overlapping with the current index.\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tfiltered.push( indices[ i ] );\n\t}\n\treturn filtered;\n};\n\n/**\n * Matches string with an array, returns the word and the index it was found on, and sorts the match instances based on\n * the index property of the match.\n *\n * @param {Array} words The array with strings to match.\n * @param {string} text The text to match the strings from the array to.\n * @returns {Array} The array with words, containing the index of the match and the matched string.\n * Returns an empty array if none are found.\n */\nvar getIndicesByWordListSorted = function( words, text ) {\n\tvar matchedWords = [];\n\n\tforEach( words, function( word ) {\n\t\tword = stripSpaces( word );\n\t\tif ( ! matchWordInSentence( word, text ) ) {\n\t\t\treturn matchedWords;\n\t\t}\n\t\tmatchedWords = matchedWords.concat( getIndicesByWord( word, text ) );\n\t} );\n\n\tmatchedWords = matchedWords.sort( function( a, b ) {\n\t\tif ( a.index < b.index ) {\n\t\t\treturn -1;\n\t\t}\n\t\tif ( a.index > b.index ) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t} );\n\n\treturn matchedWords;\n};\n\nexport {\n\tgetIndicesByWord,\n\tgetIndicesByWordList,\n\tfilterIndices,\n\tsortIndices,\n\tgetIndicesByWordListSorted,\n};\n\nexport default {\n\tgetIndicesByWord: getIndicesByWord,\n\tgetIndicesByWordList: getIndicesByWordList,\n\tfilterIndices: filterIndices,\n\tsortIndices: sortIndices,\n\tgetIndicesByWordListSorted: getIndicesByWordListSorted,\n};\n"]}