{"version":3,"sources":["../../../src/stringProcessing/specialCharacterMappings.js"],"names":["getIndicesOfWords","text","indices","words","startSearchFrom","forEach","word","currentIndex","indexOf","push","length","getIndicesOfCharacter","characterToFind","i","arraysDifference","bigArray","subarray","element","arraysOverlap","firstArray","secondArray","combinations","array","acc","xs","x","l","concat","slice","replaceCharactersByIndex","substitute","modifiedTextSplitByLetter","split","index","splice","join","replaceTurkishIs","indicesOfAllIs","sort","indicesOfIsInWordBeginnings","results","combinationsDottedI","oneCombinationDottedI","indicesNotDottedI","combinationsDotlessI","oneCombinationDotlessI","indicesSmalli","combinationsDottedi","oneCombinationDottedi","oneCombinationDotlessi","textAlternations","result","toDottedI","toDotlessI","toDottedi","toDotlessi","replaceTurkishIsMemoized"],"mappings":";;;;;;;AAAA;;;;AACA;;;;AACA;;;;AACA;;;;;;AAEA;;;;;;;AAOA,SAASA,iBAAT,CAA4BC,IAA5B,EAAmC;AAClC,KAAMC,UAAU,EAAhB;AACA,KAAMC,QAAQ,wBAAUF,IAAV,CAAd;AACA,KAAIG,kBAAkB,CAAtB;;AAEAD,OAAME,OAAN,CAAe,UAAUC,IAAV,EAAiB;AAC/B,MAAMC,eAAeN,KAAKO,OAAL,CAAcF,IAAd,EAAoBF,eAApB,CAArB;AACAF,UAAQO,IAAR,CAAcF,YAAd;AACAH,oBAAkBG,eAAeD,KAAKI,MAAtC;AACA,EAJD;;AAMA,QAAOR,OAAP;AACA;;AAGD;;;;;;;;AAQA,SAASS,qBAAT,CAAgCV,IAAhC,EAAsCW,eAAtC,EAAwD;AACvD,KAAMV,UAAU,EAAhB;;AAEA,KAAKD,KAAKO,OAAL,CAAcI,eAAd,IAAkC,CAAC,CAAxC,EAA4C;AAC3C,OAAM,IAAIC,IAAI,CAAd,EAAiBA,IAAIZ,KAAKS,MAA1B,EAAkCG,GAAlC,EAAwC;AACvC,OAAKZ,KAAMY,CAAN,MAAcD,eAAnB,EAAqC;AACpCV,YAAQO,IAAR,CAAcI,CAAd;AACA;AACD;AACD;;AAED,QAAOX,OAAP;AACA;;AAED;;;;;;;;;AASA,SAASY,gBAAT,CAA2BC,QAA3B,EAAqCC,QAArC,EAAgD;AAC/C,QAAO,sBAAQD,QAAR,EAAkB,UAAUE,OAAV,EAAoB;AAC5C,SAAS,CAAE,wBAAUD,QAAV,EAAoBC,OAApB,CAAX;AACA,EAFM,CAAP;AAGA;;AAED;;;;;;;;AAQA,SAASC,aAAT,CAAwBC,UAAxB,EAAoCC,WAApC,EAAkD;AACjD,QAAO,sBAAQD,UAAR,EAAoB,UAAUF,OAAV,EAAoB;AAC9C,SAAS,wBAAUG,WAAV,EAAuBH,OAAvB,CAAT;AACA,EAFM,CAAP;AAGA;;AAGD;;;;;;;;AAQA,SAASI,YAAT,CAAuBC,KAAvB,EAA+B;AAC9B;;;;;;;;AAQA,UAASC,GAAT,CAAcC,EAAd,EAAkBF,KAAlB,EAA0B;AACzB,MAAMG,IAAID,GAAI,CAAJ,CAAV;;AAEA,MAAK,OAAOC,CAAP,KAAa,WAAlB,EAAgC;AAC/B,UAAOH,KAAP;AACA;;AAED,OAAM,IAAIT,IAAI,CAAR,EAAWa,IAAIJ,MAAMZ,MAA3B,EAAmCG,IAAIa,CAAvC,EAA0C,EAAEb,CAA5C,EAAgD;AAC/CS,SAAMb,IAAN,CAAYa,MAAOT,CAAP,EAAWc,MAAX,CAAmBF,CAAnB,CAAZ;AACA;AACD,SAAOF,IAAKC,GAAGI,KAAH,CAAU,CAAV,CAAL,EAAoBN,KAApB,CAAP;AACA;AACD,QAAOC,IAAKD,KAAL,EAAY,CAAE,EAAF,CAAZ,EAAsBM,KAAtB,CAA6B,CAA7B,EAAiCD,MAAjC,CAAyC,CAAE,EAAF,CAAzC,CAAP;AACA;;AAGD;;;;;;;;;AASA,SAASE,wBAAT,CAAmC5B,IAAnC,EAAyCC,OAAzC,EAAkD4B,UAAlD,EAA+D;AAC9D,KAAMC,4BAA4B9B,KAAK+B,KAAL,CAAY,EAAZ,CAAlC;;AAEA9B,SAAQG,OAAR,CAAiB,UAAU4B,KAAV,EAAkB;AAClCF,4BAA0BG,MAA1B,CAAkCD,KAAlC,EAAyC,CAAzC,EAA4CH,UAA5C;AACA,EAFD;;AAIA,QAAOC,0BAA0BI,IAA1B,CAAgC,EAAhC,CAAP;AACA;;AAED;;;;;;;AAOA,SAASC,gBAAT,CAA2BnC,IAA3B,EAAkC;AACjC;AACA,KAAMoC,iBAAiB1B,sBAAuBV,IAAvB,EAA6B,GAA7B,EAAmC0B,MAAnC,CACtBhB,sBAAuBV,IAAvB,EAA6B,GAA7B,CADsB,EAEtBU,sBAAuBV,IAAvB,EAA6B,GAA7B,CAFsB,EAGtBU,sBAAuBV,IAAvB,EAA6B,GAA7B,CAHsB,CAAvB;AAKAoC,gBAAeC,IAAf;;AAEA;AACA,KAAKD,eAAe3B,MAAf,KAA0B,CAA/B,EAAmC;AAClC,SAAO,CAAET,IAAF,CAAP;AACA;AACD,KAAMsC,8BAA8BrB,cAAelB,kBAAmBC,IAAnB,CAAf,EAA0CoC,cAA1C,CAApC;;AAEA,KAAMG,UAAU,EAAhB;;AAEA;AACA,KAAMC,sBAAsBpB,aAAckB,2BAAd,CAA5B;;AAEAE,qBAAoBpC,OAApB,CAA6B,UAAUqC,qBAAV,EAAkC;AAC9D;AACA,MAAKA,0BAA0BH,2BAA/B,EAA6D;AAC5DC,WAAQ/B,IAAR,CAAc,CAAEiC,qBAAF,EAAyB,EAAzB,EAA6B,EAA7B,EAAiC,EAAjC,CAAd;AACA,GAFD,MAEO;AACN,OAAMC,oBAAoB7B,iBAAkByB,2BAAlB,EAA+CG,qBAA/C,CAA1B;;AAEA;AACA,OAAME,uBAAuBvB,aAAcsB,iBAAd,CAA7B;AACAC,wBAAqBvC,OAArB,CAA8B,UAAUwC,sBAAV,EAAmC;AAChE;AACA,QAAKA,2BAA2BF,iBAAhC,EAAoD;AACnDH,aAAQ/B,IAAR,CAAc,CAAEiC,qBAAF,EAAyBG,sBAAzB,EAAiD,EAAjD,EAAqD,EAArD,CAAd;AACA,KAFD,MAEO;AACN,SAAMC,gBAAgBhC,iBAAkB6B,iBAAlB,EAAqCE,sBAArC,CAAtB;;AAEA;AACA,SAAME,sBAAsB1B,aAAcyB,aAAd,CAA5B;;AAEAC,yBAAoB1C,OAApB,CAA6B,UAAU2C,qBAAV,EAAkC;AAC9D;AACA,UAAKA,0BAA0BF,aAA/B,EAA+C;AAC9CN,eAAQ/B,IAAR,CAAc,CAAEiC,qBAAF,EAAyBG,sBAAzB,EAAiDG,qBAAjD,EAAwE,EAAxE,CAAd;AACA,OAFD,MAEO;AACN,WAAMC,yBAAyBnC,iBAAkBgC,aAAlB,EAAiCE,qBAAjC,CAA/B;;AAEAR,eAAQ/B,IAAR,CAAc,CAAEiC,qBAAF,EAAyBG,sBAAzB,EAAiDG,qBAAjD,EAAwEC,sBAAxE,CAAd;AACA;AACD,MATD;AAUA;AACD,IArBD;AAsBA;AACD,EAhCD;;AAkCA,KAAMC,mBAAmB,EAAzB;;AAEAV,SAAQnC,OAAR,CAAiB,UAAU8C,MAAV,EAAmB;AACnC,MAAMC,YAAYvB,yBAA0B5B,IAA1B,EAAgCkD,OAAQ,CAAR,CAAhC,EAA6C,GAA7C,CAAlB;AACA,MAAME,aAAaxB,yBAA0BuB,SAA1B,EAAqCD,OAAQ,CAAR,CAArC,EAAkD,GAAlD,CAAnB;AACA,MAAMG,YAAYzB,yBAA0BwB,UAA1B,EAAsCF,OAAQ,CAAR,CAAtC,EAAmD,GAAnD,CAAlB;AACA,MAAMI,aAAa1B,yBAA0ByB,SAA1B,EAAqCH,OAAQ,CAAR,CAArC,EAAkD,GAAlD,CAAnB;AACAD,mBAAiBzC,IAAjB,CAAuB8C,UAAvB;AACA,EAND;;AAQA,QAAOL,gBAAP;AACA;;AAED,IAAMM,2BAA2B,uBAASpB,gBAAT,CAAjC;;QAGCpC,iB,GAAAA,iB;QACAW,qB,GAAAA,qB;QACAG,gB,GAAAA,gB;QACAI,a,GAAAA,a;QACAG,Y,GAAAA,Y;QACAe,gB,GAAAA,gB;QACAoB,wB,GAAAA,wB","file":"specialCharacterMappings.js","sourcesContent":["import filter from \"lodash/filter\";\nimport includes from \"lodash/includes\";\nimport memoize from \"lodash/memoize\";\nimport getWords from \"./getWords\";\n\n/**\n * Gets positions of the first character of a word in the input text.\n *\n * @param {string} text The original text, for which the indices of word beginnings need to be determined.\n *\n * @returns {Array} indices The array of indices in the text at which words start.\n */\nfunction getIndicesOfWords( text ) {\n\tconst indices = [];\n\tconst words = getWords( text );\n\tlet startSearchFrom = 0;\n\n\twords.forEach( function( word ) {\n\t\tconst currentIndex = text.indexOf( word, startSearchFrom );\n\t\tindices.push( currentIndex );\n\t\tstartSearchFrom = currentIndex + word.length;\n\t} );\n\n\treturn indices;\n}\n\n\n/**\n * Gets indices of a specific character in the input text.\n *\n * @param {string} text The original text, for which the indices of specific characters have to be determined.\n * @param {string} characterToFind The character that needs to be found in the text.\n *\n * @returns {Array} indices The array of indices in the text at which the characterToFind occurs.\n */\nfunction getIndicesOfCharacter( text, characterToFind ) {\n\tconst indices = [];\n\n\tif ( text.indexOf( characterToFind ) > -1 ) {\n\t\tfor ( let i = 0; i < text.length; i++ ) {\n\t\t\tif ( text[ i ] === characterToFind ) {\n\t\t\t\tindices.push( i );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn indices;\n}\n\n/**\n * Compares two arrays of which the second array is the sub-array of the first array.\n * Returns the array of elements of the first array which are not in the second array.\n *\n * @param {Array} bigArray The array with all elements.\n * @param {Array} subarray The array with some elements from the bigArray.\n *\n * @returns {Array} difference An array of all elements of bigArray which are not in subarray.\n */\nfunction arraysDifference( bigArray, subarray ) {\n\treturn filter( bigArray, function( element ) {\n\t\treturn ( ! includes( subarray, element ) );\n\t} );\n}\n\n/**\n * Compares two arrays and returns the array of elements that occur in both arrays.\n *\n * @param {Array} firstArray The first array with elements to compare.\n * @param {Array} secondArray The second array with elements to compare.\n *\n * @returns {Array} overlap An array of all elements of firstArray which are also in secondArray.\n */\nfunction arraysOverlap( firstArray, secondArray ) {\n\treturn filter( firstArray, function( element ) {\n\t\treturn ( includes( secondArray, element ) );\n\t} );\n}\n\n\n/**\n * Generates all possible combinations of the elements of an array (treated as unique).\n * https://gist.github.com/jpillora/4435759\n *\n * @param {Array} array The array with elements that should be combined.\n *\n * @returns {Array} result An array of all possible combinations of elements of the original array.\n */\nfunction combinations( array ) {\n\t/**\n\t * A recursive function that iterates through all elements of an array to produce its combinations.\n\t *\n\t * @param {Array} xs The array to start accumulating with.\n\t * @param {Array} array The array with elements that should be combined.\n\t *\n\t * @returns {Array} result An array of all possible combinations of elements of the original array.\n\t */\n\tfunction acc( xs, array ) {\n\t\tconst x = xs[ 0 ];\n\n\t\tif ( typeof x === \"undefined\" ) {\n\t\t\treturn array;\n\t\t}\n\n\t\tfor ( let i = 0, l = array.length; i < l; ++i ) {\n\t\t\tarray.push( array[ i ].concat( x ) );\n\t\t}\n\t\treturn acc( xs.slice( 1 ), array );\n\t}\n\treturn acc( array, [ [ ] ] ).slice( 1 ).concat( [ [] ] );\n}\n\n\n/**\n * Replaces characters on specified indices in the input text.\n *\n * @param {string} text The original text, for which the characters have to be substituted.\n * @param {Array} indices The array of indices that have to be substituted.\n * @param {string} substitute The character that is used to substitute in the text.\n *\n * @returns {string} result The string of the original text with the characters on specified indices are substituted with the substitute character.\n */\nfunction replaceCharactersByIndex( text, indices, substitute ) {\n\tconst modifiedTextSplitByLetter = text.split( \"\" );\n\n\tindices.forEach( function( index ) {\n\t\tmodifiedTextSplitByLetter.splice( index, 1, substitute );\n\t} );\n\n\treturn modifiedTextSplitByLetter.join( \"\" );\n}\n\n/**\n * Generates upper and lower case for Turkish strings that contain characters İ or ı, which appear to not be processed correctly by regexes.\n *\n * @param {string} text The text to build possible upper and lower case alternatives.\n *\n * @returns {Array} An array of strings that contains all possible upper and lower case alternatives of the original string\n */\nfunction replaceTurkishIs( text ) {\n\t// Get indices of all occurrences of İ, I, i, or ı.\n\tconst indicesOfAllIs = getIndicesOfCharacter( text, \"İ\" ).concat(\n\t\tgetIndicesOfCharacter( text, \"I\" ),\n\t\tgetIndicesOfCharacter( text, \"i\" ),\n\t\tgetIndicesOfCharacter( text, \"ı\" )\n\t);\n\tindicesOfAllIs.sort();\n\n\t// If there are no Is return the text\n\tif ( indicesOfAllIs.length === 0 ) {\n\t\treturn [ text ];\n\t}\n\tconst indicesOfIsInWordBeginnings = arraysOverlap( getIndicesOfWords( text ), indicesOfAllIs );\n\n\tconst results = [];\n\n\t// First round of creating combinations: assign which indices will be replaced by İ\n\tconst combinationsDottedI = combinations( indicesOfIsInWordBeginnings );\n\n\tcombinationsDottedI.forEach( function( oneCombinationDottedI ) {\n\t\t// If the combination is full array, just add it to results immediately without going through the rest of iterations.\n\t\tif ( oneCombinationDottedI === indicesOfIsInWordBeginnings ) {\n\t\t\tresults.push( [ oneCombinationDottedI, [], [], [] ] );\n\t\t} else {\n\t\t\tconst indicesNotDottedI = arraysDifference( indicesOfIsInWordBeginnings, oneCombinationDottedI );\n\n\t\t\t// Second round of creating combinations: assign which indices will be replaced by I\n\t\t\tconst combinationsDotlessI = combinations( indicesNotDottedI );\n\t\t\tcombinationsDotlessI.forEach( function( oneCombinationDotlessI ) {\n\t\t\t\t// If the combination is full array, just add it to results immediately without going through the rest of iterations.\n\t\t\t\tif ( oneCombinationDotlessI === indicesNotDottedI ) {\n\t\t\t\t\tresults.push( [ oneCombinationDottedI, oneCombinationDotlessI, [], [] ] );\n\t\t\t\t} else {\n\t\t\t\t\tconst indicesSmalli = arraysDifference( indicesNotDottedI, oneCombinationDotlessI );\n\n\t\t\t\t\t// Third round of creating combinations: assign which indices will be replaced by i\n\t\t\t\t\tconst combinationsDottedi = combinations( indicesSmalli );\n\n\t\t\t\t\tcombinationsDottedi.forEach( function( oneCombinationDottedi ) {\n\t\t\t\t\t\t// If the combination is full array, just add it to results immediately without going through the rest of iterations.\n\t\t\t\t\t\tif ( oneCombinationDottedi === indicesSmalli ) {\n\t\t\t\t\t\t\tresults.push( [ oneCombinationDottedI, oneCombinationDotlessI, oneCombinationDottedi, [] ] );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst oneCombinationDotlessi = arraysDifference( indicesSmalli, oneCombinationDottedi );\n\n\t\t\t\t\t\t\tresults.push( [ oneCombinationDottedI, oneCombinationDotlessI, oneCombinationDottedi, oneCombinationDotlessi ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\t} );\n\n\tconst textAlternations = [];\n\n\tresults.forEach( function( result ) {\n\t\tconst toDottedI = replaceCharactersByIndex( text, result[ 0 ], \"İ\" );\n\t\tconst toDotlessI = replaceCharactersByIndex( toDottedI, result[ 1 ], \"I\" );\n\t\tconst toDottedi = replaceCharactersByIndex( toDotlessI, result[ 2 ], \"i\" );\n\t\tconst toDotlessi = replaceCharactersByIndex( toDottedi, result[ 3 ], \"ı\" );\n\t\ttextAlternations.push( toDotlessi );\n\t} );\n\n\treturn textAlternations;\n}\n\nconst replaceTurkishIsMemoized = memoize( replaceTurkishIs );\n\nexport {\n\tgetIndicesOfWords,\n\tgetIndicesOfCharacter,\n\tarraysDifference,\n\tarraysOverlap,\n\tcombinations,\n\treplaceTurkishIs,\n\treplaceTurkishIsMemoized,\n};\n"]}