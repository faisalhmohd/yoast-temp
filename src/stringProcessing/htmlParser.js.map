{"version":3,"sources":["../../../src/stringProcessing/htmlParser.js"],"names":["text","textArray","parser","write","join","inScriptBlock","inlineTags","Parser","onopentag","tagName","nodeValue","nodeValueType","Object","keys","nodeValueString","forEach","node","push","ontext","onclosetag","decodeEntities"],"mappings":";;;;;;kBA+Ee,UAAUA,IAAV,EAAiB;AAC/BC,aAAY,EAAZ;AACAC,QAAOC,KAAP,CAAcH,IAAd;AACA,QAAOC,UAAUG,IAAV,CAAgB,EAAhB,CAAP;AACA,C;;AAlFD;;;;AAGA;;;;AAEA;AANA;AAOA,IAAIH,kBAAJ;;AAEA;AACA,IAAII,gBAAgB,KAApB;;AAEA;AACA,IAAMC,aAAa,CAAE,QAAF,EAAY,OAAZ,EAAqB,MAArB,EAA6B,KAA7B,CAAnB;;AAEA;;;AAGA,IAAMJ,SAAS,IAAI,qBAAWK,MAAf,CAAuB;AACrC;;;;;;;;AAQAC,YAAW,mBAAUC,OAAV,EAAmBC,SAAnB,EAA+B;AACzC,MAAK,wBAAUJ,UAAV,EAAsBG,OAAtB,CAAL,EAAuC;AACtCJ,mBAAgB,IAAhB;AACA;AACA;;AAED,MAAMM,gBAAgBC,OAAOC,IAAP,CAAaH,SAAb,CAAtB;AACA,MAAII,kBAAkB,EAAtB;;AAEAH,gBAAcI,OAAd,CAAuB,UAAUC,IAAV,EAAiB;AACvC;AACAF,sBAAmB,MAAME,IAAN,GAAa,IAAb,GAAoBN,UAAWM,IAAX,CAApB,GAAwC,GAA3D;AACA,GAHD;;AAKAf,YAAUgB,IAAV,CAAgB,MAAMR,OAAN,GAAgBK,eAAhB,GAAkC,GAAlD;AACA,EAxBoC;AAyBrC;;;;;;;AAOAI,SAAQ,gBAAUlB,IAAV,EAAiB;AACxB,MAAK,CAAEK,aAAP,EAAuB;AACtBJ,aAAUgB,IAAV,CAAgBjB,IAAhB;AACA;AACD,EApCoC;AAqCrC;;;;;;;;AAQAmB,aAAY,oBAAUV,OAAV,EAAoB;AAC/B,MAAK,wBAAUH,UAAV,EAAsBG,OAAtB,CAAL,EAAuC;AACtCJ,mBAAgB,KAAhB;AACA;AACA;;AAEDJ,YAAUgB,IAAV,CAAgB,OAAOR,OAAP,GAAiB,GAAjC;AACA;AApDoC,CAAvB,EAqDZ,EAAEW,gBAAgB,IAAlB,EArDY,CAAf;;AAuDA","file":"htmlParser.js","sourcesContent":["// We use an external library, which can be found here: https://github.com/fb55/htmlparser2.\nimport htmlparser from \"htmlparser2\";\n\n\nimport { includes } from \"lodash-es\";\n\n// The array containing the text parts without the blocks defined in inlineTags.\nlet textArray;\n\n// False when we are not in a block defined in inlineTags. True if we are.\nlet inScriptBlock = false;\n\n// The blocks we filter out of the text that needs to be parsed.\nconst inlineTags = [ \"script\", \"style\", \"code\", \"pre\" ];\n\n/**\n * Parses the text.\n */\nconst parser = new htmlparser.Parser( {\n\t/**\n\t * Handles the opening tag. If the opening tag is included in the inlineTags array, set inScriptBlock to true.\n\t * If the opening tag is not included in the inlineTags array, push the tag to the textArray.\n\t *\n\t * @param {string} tagName The tag name.\n\t * @param {object} nodeValue The attribute with the keys and values of the tag.\n\t * @returns {void}\n\t */\n\tonopentag: function( tagName, nodeValue ) {\n\t\tif ( includes( inlineTags, tagName ) ) {\n\t\t\tinScriptBlock = true;\n\t\t\treturn;\n\t\t}\n\n\t\tconst nodeValueType = Object.keys( nodeValue );\n\t\tlet nodeValueString = \"\";\n\n\t\tnodeValueType.forEach( function( node ) {\n\t\t\t// Build the tag again.\n\t\t\tnodeValueString += \" \" + node + \"='\" + nodeValue[ node ] + \"'\";\n\t\t} );\n\n\t\ttextArray.push( \"<\" + tagName + nodeValueString + \">\" );\n\t},\n\t/**\n\t * Handles the text that doesn't contain opening or closing tags. If inScriptBlock is false, the text gets pushed to the textArray array.\n\t *\n\t * @param {string} text The text that doesn't contain opening or closing tags.\n\t *\n\t * @returns {void}\n\t */\n\tontext: function( text ) {\n\t\tif ( ! inScriptBlock ) {\n\t\t\ttextArray.push( text );\n\t\t}\n\t},\n\t/**\n\t * Handles the closing tag. If the closing tag is included in the inlineTags array, set inScriptBlock to false.\n\t * If the closing tag is not included in the inlineTags array, push the tag to the textArray.\n\t *\n\t * @param {string} tagName The tag name.\n\t *\n\t * @returns {void}\n\t */\n\tonclosetag: function( tagName ) {\n\t\tif ( includes( inlineTags, tagName ) ) {\n\t\t\tinScriptBlock = false;\n\t\t\treturn;\n\t\t}\n\n\t\ttextArray.push( \"</\" + tagName + \">\" );\n\t},\n}, { decodeEntities: true } );\n\n/**\n * Calls the htmlparser and returns the text without the HTML blocks as defined in the inlineTags array.\n *\n * @param {string} text The text to parse.\n * @returns {string} The text without the HTML blocks as defined in the inlineTags array.\n */\nexport default function( text ) {\n\ttextArray = [];\n\tparser.write( text );\n\treturn textArray.join( \"\" );\n}\n"]}