{"version":3,"sources":["../../../../../../src/researches/passiveVoice/periphrastic/freeAuxiliaryParticipleOrder/nonDirectParticiplePrecedenceException.js"],"names":["sentencePart","participle","auxiliaries","language","auxiliariesUnique","auxiliaryIndices","participleIndex","indexOf","nonDirectParticiplePrecendenceExceptionRegex","cannotBeBetweenAuxiliaryAndParticiplePolish","matches","filter","auxiliaryIndex","index","length","participleAuxiliary","precedenceExceptionIndices","remaningPrecedenceExceptionIndices","precedenceExceptionIndex","cannotBeBetweenPassiveAuxiliaryAndParticiple"],"mappings":";;;;;;kBAuBe,UAAUA,YAAV,EAAwBC,UAAxB,EAAoCC,WAApC,EAAiDC,QAAjD,EAA4D;AAC1E,KAAMC,oBAAoB,oBAAMF,WAAN,CAA1B;;AAEA,KAAMG,mBAAmB,yCAA4BD,iBAA5B,EAA+CJ,YAA/C,CAAzB;;AAEA,KAAMM,kBAAkBN,aAAaO,OAAb,CAAsBN,UAAtB,CAAxB;AACA,KAAIO,qDAAJ;;AAEA,SAASL,QAAT;AACC,OAAK,IAAL;AACCK,kDAA+C,oCAAcC,2CAAd,CAA/C;AACA;AAHF;;AAMA;AACA,KAAMC,UAAUL,iBAAiBM,MAAjB,CAAyB;AAAA,SAAkBC,eAAeC,KAAf,GAAuBP,eAAzC;AAAA,EAAzB,CAAhB;;AAEA;AACA,KAAKI,QAAQI,MAAR,KAAmB,CAAxB,EAA4B;AAC3B,SAAO,KAAP;AACA;;AAED;AACA,KAAMC,sBAAsBL,QAASA,QAAQI,MAAR,GAAiB,CAA1B,CAA5B;;AAEA,KAAME,6BAA6B,mCAAgBhB,YAAhB,EAA8BQ,4CAA9B,CAAnC;;AAEA;AACA,KAAMS,qCAAqCD,2BAA2BL,MAA3B,CAAmC;AAAA,SAC3EO,yBAAyBL,KAAzB,GAAiCE,oBAAoBF,KAArD,IAA8DK,yBAAyBL,KAAzB,GAAiCP,eADpB;AAAA,EAAnC,CAA3C;;AAGA,QAAOW,mCAAmCH,MAAnC,GAA4C,CAAnD;AACA,C;;AAvDD;;AAEA;;;;AACA;;;;AAEA;;;;AAIA;;;;AAFA,IAAML,8CACN,+BAAqDU,4CADrD;;AAKA","file":"nonDirectParticiplePrecedenceException.js","sourcesContent":["import { uniq } from \"lodash-es\";\n\nimport arrayToRegex from \"../../../../stringProcessing/createRegexFromArray.js\";\nimport getWordIndices from \"../getIndicesWithRegex.js\";\n\nimport cannotBeBetweenAuxiliaryAndParticiplePolishFactory from \"../../../polish/functionWords.js\";\n\nconst cannotBeBetweenAuxiliaryAndParticiplePolish =\ncannotBeBetweenAuxiliaryAndParticiplePolishFactory().cannotBeBetweenPassiveAuxiliaryAndParticiple;\nimport { getIndicesByWordListSorted } from \"../../../../stringProcessing/indices.js\";\n\n\n/**\n * Checks whether there are any exception words in between the auxiliary and participle. If there are, it doesn't return a passive.\n *\n * @param {string} sentencePart The sentence part that contains the participle.\n * @param {string} participle The participle in the sentence part.\n * @param {string} auxiliaries One or more auxiliaries in the sentence part.\n * @param {string} language The language of the participle.\n *\n * @returns {boolean} Returns true if a word from the 'cannot be between passive auxiliary and participle' exception list\n * appears anywhere in between the last (closest to participle) auxiliary and the participle.\n */\nexport default function( sentencePart, participle, auxiliaries, language ) {\n\tconst auxiliariesUnique = uniq( auxiliaries );\n\n\tconst auxiliaryIndices = getIndicesByWordListSorted( auxiliariesUnique, sentencePart );\n\n\tconst participleIndex = sentencePart.indexOf( participle );\n\tlet nonDirectParticiplePrecendenceExceptionRegex;\n\n\tswitch ( language ) {\n\t\tcase \"pl\":\n\t\t\tnonDirectParticiplePrecendenceExceptionRegex = arrayToRegex( cannotBeBetweenAuxiliaryAndParticiplePolish );\n\t\t\tbreak;\n\t}\n\n\t// This exception is only applicable for passive constructions in which the auxiliary precedes the participle.\n\tconst matches = auxiliaryIndices.filter( auxiliaryIndex => auxiliaryIndex.index < participleIndex );\n\n\t// If there are no auxiliaries before the participle, this exception is not applicable.\n\tif ( matches.length === 0 ) {\n\t\treturn false;\n\t}\n\n\t// We pick the auxiliary closest to the participle, since that is most likely the one belonging to the participle.\n\tconst participleAuxiliary = matches[ matches.length - 1 ];\n\n\tconst precedenceExceptionIndices = getWordIndices( sentencePart, nonDirectParticiplePrecendenceExceptionRegex );\n\n\t// Check whether there are any precendence words between the auxiliary and the participle.\n\tconst remaningPrecedenceExceptionIndices = precedenceExceptionIndices.filter( precedenceExceptionIndex =>\n\t\t( precedenceExceptionIndex.index > participleAuxiliary.index && precedenceExceptionIndex.index < participleIndex ) );\n\n\treturn remaningPrecedenceExceptionIndices.length > 0;\n}\n"]}