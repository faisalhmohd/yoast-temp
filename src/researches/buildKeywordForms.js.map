{"version":3,"sources":["../../../src/researches/buildKeywordForms.js"],"names":["getFormsForLanguage","getFunctionWords","filterFunctionWords","array","language","functionWords","length","arrayFiltered","word","all","trim","toLocaleLowerCase","buildForms","keyphrase","morphologyData","doubleQuotes","substring","concat","words","forms","getForms","forEach","wordToLowerCase","push","formsOfThisWord","variationsApostrophes","filter","Boolean","collectKeyphraseAndSynonymsForms","synonyms","synonymsSplit","keyphraseForms","synonymsForms","map","synonym","primeMorphologyData","collectForms","collectFormsWithMorphologyData","research","paper","researcher","getLocale","getData","getKeyword","getSynonyms"],"mappings":"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","file":"buildKeywordForms.js","sourcesContent":["import getFormsForLanguageFactory from \"../helpers/getFormsForLanguage.js\";\nconst getFormsForLanguage = getFormsForLanguageFactory();\nimport getWords from \"../stringProcessing/getWords.js\";\nimport getLanguage from \"../helpers/getLanguage.js\";\nimport getFunctionWordsFactory from \"../helpers/getFunctionWords.js\";\nconst getFunctionWords = getFunctionWordsFactory();\nimport parseSynonyms from \"../stringProcessing/parseSynonyms\";\nimport { getVariationsApostrophe } from \"../stringProcessing/getVariationsApostrophe\";\nimport { getVariationsApostropheInArray } from \"../stringProcessing/getVariationsApostrophe\";\n\nimport { includes } from \"lodash-es\";\nimport { filter } from \"lodash-es\";\nimport { isUndefined } from \"lodash-es\";\nimport { escapeRegExp } from \"lodash-es\";\nimport { uniq as unique } from \"lodash-es\";\nimport { flatten } from \"lodash-es\";\nimport { get } from \"lodash-es\";\nimport { memoize } from \"lodash-es\";\n\n/**\n * Filters function words from an array of words based on the language.\n *\n * @param {Array} array The words to check.\n * @param {string} language The language to take function words for.\n *\n * @returns {Array} The original array with the function words filtered out.\n */\nconst filterFunctionWords = function( array, language ) {\n\tif ( isUndefined( language ) || language === \"\" ) {\n\t\tlanguage = \"en\";\n\t}\n\n\tconst functionWords = get( getFunctionWords, [ language ], [] );\n\n\tif ( array.length > 1 ) {\n\t\tconst arrayFiltered = filter( array, function( word ) {\n\t\t\treturn ( ! includes( functionWords.all, word.trim().toLocaleLowerCase() ) );\n\t\t} );\n\n\t\tif ( arrayFiltered.length > 0 ) {\n\t\t\treturn arrayFiltered;\n\t\t}\n\t}\n\n\treturn array;\n};\n\n/**\n * Analyzes the focus keyword string. Checks if morphology is requested or if the user wants to match exact string.\n * If morphology is required the module builds all word forms for all words (if no function words list available) or\n * for all content words (i.e., excluding prepositions, articles, conjunctions, if the function words list is available).\n *\n * @param {string} keyphrase The keyphrase of the paper (or a synonym phrase) to get forms for.\n * @param {string} language The language to use for morphological analyzer and for function words.\n * @param {Object} morphologyData The available morphology data per language (false if unavailable).\n *\n * @returns {Array} Array of all forms to be searched for keyword-based assessments.\n */\nconst buildForms = function( keyphrase, language, morphologyData ) {\n\tif ( isUndefined( keyphrase ) || keyphrase === \"\" ) {\n\t\treturn [];\n\t}\n\n\t/*\n\t * If the keyphrase is embedded in double quotation marks, return keyword itself, without outer-most quotation marks.\n\t * Additionally, provide apostrophe variations.\n\t */\n\n\tconst doubleQuotes = [ \"“\", \"”\", \"〝\", \"〞\", \"〟\", \"‟\", \"„\", \"\\\"\" ];\n\tif ( includes( doubleQuotes, keyphrase[ 0 ] ) && includes( doubleQuotes, keyphrase[ keyphrase.length - 1 ] ) ) {\n\t\tkeyphrase = keyphrase.substring( 1, keyphrase.length - 1 );\n\t\treturn [ unique( [].concat( escapeRegExp( keyphrase ), getVariationsApostrophe( keyphrase ) ) ) ];\n\t}\n\n\tconst words = filterFunctionWords( getWords( keyphrase ), language );\n\n\tconst forms = [];\n\n\tconst getForms = getFormsForLanguage[ language ];\n\t/*\n\t * Only returns the keyword and the keyword with apostrophe variations if morphological forms cannot be built.\n\t * Otherwise additionally returns the morphological forms.\n\t */\n\tif ( morphologyData === false || isUndefined( getForms ) ) {\n\t\twords.forEach( function( word ) {\n\t\t\tconst wordToLowerCase = escapeRegExp( word.toLocaleLowerCase( language ) );\n\n\t\t\tforms.push( unique( [].concat( wordToLowerCase, getVariationsApostrophe( wordToLowerCase ) ) ) );\n\t\t} );\n\t} else {\n\t\twords.forEach( function( word ) {\n\t\t\tconst wordToLowerCase = escapeRegExp( word.toLocaleLowerCase() );\n\t\t\tconst formsOfThisWord = getForms( wordToLowerCase, morphologyData );\n\t\t\tconst variationsApostrophes = getVariationsApostropheInArray( formsOfThisWord );\n\t\t\tforms.push( unique( flatten( formsOfThisWord.concat( variationsApostrophes ) ) ).filter( Boolean ) );\n\t\t} );\n\t}\n\n\treturn forms;\n};\n\n/**\n * Builds morphological forms of words of the keyphrase and of each synonym phrase.\n *\n * @param {string} keyphrase The paper's keyphrase.\n * @param {string} synonyms The paper's synonyms.\n * @param {string} language The paper's language.\n * @param {Object} morphologyData The available morphology data to be used by the getForms function (language specific).\n *\n * @returns {Object} Object with an array of keyphrase forms and an array of arrays of synonyms forms.\n */\nconst collectKeyphraseAndSynonymsForms = function( keyphrase, synonyms, language = \"en\", morphologyData ) {\n\tconst synonymsSplit = parseSynonyms( synonyms );\n\n\tconst keyphraseForms = buildForms( keyphrase, language, morphologyData );\n\tconst synonymsForms = synonymsSplit.map( synonym => buildForms( synonym, language, morphologyData ) );\n\n\treturn {\n\t\tkeyphraseForms: keyphraseForms,\n\t\tsynonymsForms: synonymsForms,\n\t};\n};\n\n/**\n * Caches morphological forms depending on the currently available morphologyData and (separately) keyphrase, synonyms,\n * and language. In this way, if the morphologyData remains the same in multiple calls of this function, the function\n * that collects actual morphological forms only needs to check if the keyphrase, synonyms and language also remain the\n * same to return the cached result. The joining of keyphrase, synonyms and language for this function is needed,\n * because by default memoize caches by the first key only, which in the current case would mean that the function would\n * return the cached forms if the keyphrase has not changed (without checking if synonyms and language were changed).\n *\n * @param {Object|boolean} morphologyData The available morphology data.\n *\n * @returns {function} The function that collects the forms for a given set of keyphrase, synonyms, language and\n * morphologyData.\n */\nconst primeMorphologyData = memoize( ( morphologyData ) => {\n\treturn memoize( ( keyphrase, synonyms, language = \"en\" ) => {\n\t\treturn collectKeyphraseAndSynonymsForms( keyphrase, synonyms, language, morphologyData );\n\t}, ( keyphrase, synonyms, language ) => {\n\t\treturn keyphrase + \",\" + synonyms + \",\" + language;\n\t} );\n} );\n\n\n/**\n * Retrieves morphological forms of words of the keyphrase and of each synonym phrase using the function that caches\n * the results of previous calls of this function.\n *\n * @param {string} keyphrase The paper's keyphrase.\n * @param {string} synonyms The paper's synonyms.\n * @param {string} language The paper's language.\n * @param {Object} morphologyData The available morphology data to be used by the getForms function (language specific).\n *\n * @returns {Object} Object with an array of keyphrase forms and an array of arrays of synonyms forms.\n */\nfunction collectForms( keyphrase, synonyms, language = \"en\", morphologyData ) {\n\tconst collectFormsWithMorphologyData = primeMorphologyData( morphologyData );\n\n\treturn collectFormsWithMorphologyData( keyphrase, synonyms, language );\n}\n\n/**\n * Calls the function that builds keyphrase and synonyms forms for a specific research data.\n *\n * @param {Paper} paper The paper to build keyphrase and synonym forms for.\n * @param {Researcher} researcher The researcher prototype.\n *\n * @returns {Object} Object with an array of keyphrase forms and an array of arrays of synonyms forms.\n */\nfunction research( paper, researcher ) {\n\tconst language = getLanguage( paper.getLocale() );\n\n\tconst morphologyData = get( researcher.getData( \"morphology\" ), [ language ], false );\n\n\treturn collectForms( paper.getKeyword(), paper.getSynonyms(), language, morphologyData );\n}\n\nexport {\n\tfilterFunctionWords,\n\tbuildForms,\n\tcollectForms,\n\tresearch,\n};\n"]}