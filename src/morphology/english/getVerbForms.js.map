{"version":3,"sources":["../../../../src/morphology/english/getVerbForms.js"],"names":["normalizePrefixed","word","verbPrefixes","property","hasOwnProperty","RegExp","sevenLetterHyphenPrefixes","test","normalizedWord","replace","prefix","substring","sevenLetterPrefixes","fiveLetterHyphenPrefixes","fiveLetterPrefixes","fourLetterHyphenPrefixes","fourLetterPrefixes","threeLetterHyphenPrefixes","threeLetterPrefixes","twoLetterHyphenPrefixes","twoLetterPrefixes","oneLetterPrefixes","checkIrregulars","irregularVerbs","irregulars","forEach","paradigm","wordInParadigm","normalizedIrregular","map","verb","concat","endsWithS","wordLength","length","endsWithIng","endsWithEd","getInfinitive","sFormToInfinitiveRegex","ingFormToInfinitiveRegex","edFormToInfinitiveRegex","infinitive","guessedForm","getVerbForms","verbsData","regexVerb","irregular","forms","sFormToInfinitive","ingFormToInfinitive","edFormToInfinitive","push","infinitiveToSForm","infinitiveToIngForm","infinitiveToEdForm","filter","Boolean"],"mappings":"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","file":"getVerbForms.js","sourcesContent":["// \"use strict\";\nimport createRulesFromMorphologyData from \"../morphoHelpers/createRulesFromMorphologyData.js\";\nimport { buildOneFormFromRegex } from \"../morphoHelpers/buildFormRule\";\n\nimport { isUndefined } from \"lodash-es\";\nimport { uniq as unique } from \"lodash-es\";\nimport { flatten } from \"lodash-es\";\n\n/**\n * Checks if the input word has one of the standard verb prefixes and if so returns a prefix and a de-prefixed verb to be\n * further used to compare with the list of irregular verbs.\n *\n * @param {string} word The word for which to determine if it has one of the standard verb prefixes.\n * @param {Object} verbPrefixes The collection of verb prefixes to be used for normalization\n *\n * @returns {Array} Array of word forms from the exception list.\n */\nconst normalizePrefixed = function( word, verbPrefixes ) {\n\tfor ( const property in verbPrefixes ) {\n\t\tif ( verbPrefixes.hasOwnProperty( property ) ) {\n\t\t\tverbPrefixes[ property ] = new RegExp( verbPrefixes[ property ], \"i\" );\n\t\t}\n\t}\n\n\tif ( verbPrefixes.sevenLetterHyphenPrefixes.test( word ) === true ) {\n\t\treturn {\n\t\t\tnormalizedWord: word.replace( verbPrefixes.sevenLetterHyphenPrefixes, \"\" ),\n\t\t\tprefix: word.substring( 0, 8 ),\n\t\t};\n\t}\n\n\tif ( verbPrefixes.sevenLetterPrefixes.test( word ) === true ) {\n\t\treturn {\n\t\t\tnormalizedWord: word.replace( verbPrefixes.sevenLetterPrefixes, \"\" ),\n\t\t\tprefix: word.substring( 0, 7 ),\n\t\t};\n\t}\n\n\tif ( verbPrefixes.fiveLetterHyphenPrefixes.test( word ) === true ) {\n\t\treturn {\n\t\t\tnormalizedWord: word.replace( verbPrefixes.fiveLetterHyphenPrefixes, \"\" ),\n\t\t\tprefix: word.substring( 0, 6 ),\n\t\t};\n\t}\n\n\tif ( verbPrefixes.fiveLetterPrefixes.test( word ) === true ) {\n\t\treturn {\n\t\t\tnormalizedWord: word.replace( verbPrefixes.fiveLetterPrefixes, \"\" ),\n\t\t\tprefix: word.substring( 0, 5 ),\n\t\t};\n\t}\n\n\tif ( verbPrefixes.fourLetterHyphenPrefixes.test( word ) === true ) {\n\t\treturn {\n\t\t\tnormalizedWord: word.replace( verbPrefixes.fourLetterHyphenPrefixes, \"\" ),\n\t\t\tprefix: word.substring( 0, 5 ),\n\t\t};\n\t}\n\n\tif ( verbPrefixes.fourLetterPrefixes.test( word ) === true ) {\n\t\treturn {\n\t\t\tnormalizedWord: word.replace( verbPrefixes.fourLetterPrefixes, \"\" ),\n\t\t\tprefix: word.substring( 0, 4 ),\n\t\t};\n\t}\n\n\tif ( verbPrefixes.threeLetterHyphenPrefixes.test( word ) === true ) {\n\t\treturn {\n\t\t\tnormalizedWord: word.replace( verbPrefixes.threeLetterHyphenPrefixes, \"\" ),\n\t\t\tprefix: word.substring( 0, 4 ),\n\t\t};\n\t}\n\n\tif ( verbPrefixes.threeLetterPrefixes.test( word ) === true ) {\n\t\treturn {\n\t\t\tnormalizedWord: word.replace( verbPrefixes.threeLetterPrefixes, \"\" ),\n\t\t\tprefix: word.substring( 0, 3 ),\n\t\t};\n\t}\n\n\tif ( verbPrefixes.twoLetterHyphenPrefixes.test( word ) === true ) {\n\t\treturn {\n\t\t\tnormalizedWord: word.replace( verbPrefixes.twoLetterHyphenPrefixes, \"\" ),\n\t\t\tprefix: word.substring( 0, 3 ),\n\t\t};\n\t}\n\n\tif ( verbPrefixes.twoLetterPrefixes.test( word ) === true ) {\n\t\treturn {\n\t\t\tnormalizedWord: word.replace( verbPrefixes.twoLetterPrefixes, \"\" ),\n\t\t\tprefix: word.substring( 0, 2 ),\n\t\t};\n\t}\n\n\tif ( verbPrefixes.oneLetterPrefixes.test( word ) === true ) {\n\t\treturn {\n\t\t\tnormalizedWord: word.replace( verbPrefixes.oneLetterPrefixes, \"\" ),\n\t\t\tprefix: word.substring( 0, 1 ),\n\t\t};\n\t}\n};\n\n/**\n * Checks if the input word occurs in the list of exception verbs and if so returns all its irregular forms.\n * If not checks if it is an irregular verb with one of the standard verb prefixes, if so returns all irregular prefixed forms.\n *\n * @param {string} word The word for which to determine its irregular forms.\n * @param {Array} irregularVerbs The array of irregular verbs available for this language.\n * @param {Object} verbPrefixes The collection of verb prefixes to be used for normalization of irregular verbs.\n *\n * @returns {Array} Array of word forms from the exception list.\n */\nconst checkIrregulars = function( word, irregularVerbs, verbPrefixes ) {\n\tlet irregulars;\n\n\tirregularVerbs.forEach( function( paradigm ) {\n\t\tparadigm.forEach( function( wordInParadigm ) {\n\t\t\tif ( wordInParadigm === word ) {\n\t\t\t\tirregulars = paradigm;\n\t\t\t}\n\t\t} );\n\t} );\n\n\tif ( isUndefined( irregulars ) ) {\n\t\tconst normalizedIrregular = normalizePrefixed( word, verbPrefixes );\n\n\t\tif ( ! isUndefined( normalizedIrregular ) ) {\n\t\t\tirregularVerbs.forEach( function( paradigm ) {\n\t\t\t\tparadigm.forEach( function( wordInParadigm ) {\n\t\t\t\t\tif ( wordInParadigm === normalizedIrregular.normalizedWord ) {\n\t\t\t\t\t\tirregulars = paradigm.map( function( verb ) {\n\t\t\t\t\t\t\treturn normalizedIrregular.prefix.concat( verb );\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t} );\n\t\t}\n\t}\n\n\treturn irregulars;\n};\n\n/**\n * Checks if the input word ends with \"s\".\n *\n * @param {string} word The word to check.\n *\n * @returns {boolean} True if the word ends with \"s\".\n */\nconst endsWithS = function( word ) {\n\tconst wordLength = word.length;\n\t// Consider only words of four letters or more to be s-forms (otherwise, words like \"its\" are being treated as verb forms).\n\tif ( wordLength > 3 ) {\n\t\treturn word[ word.length - 1 ] === \"s\";\n\t}\n\treturn false;\n};\n\n/**\n * Checks if the input word ends with \"ing\".\n *\n * @param {string} word The word to check.\n *\n * @returns {boolean} True if the word ends with \"ing\".\n */\nconst endsWithIng = function( word ) {\n\tconst wordLength = word.length;\n\t// Consider only words of five letters or more to be ing forms (otherwise, words like \"ping\" are being treated as verb forms).\n\tif ( wordLength > 4 ) {\n\t\treturn word.substring( word.length - 3, word.length ) === \"ing\";\n\t}\n\treturn false;\n};\n\n/**\n * Checks if the input word ends with \"ed\".\n *\n * @param {string} word The word to check.\n *\n * @returns {boolean} True if the word ends with \"ed\".\n */\nconst endsWithEd = function( word ) {\n\tconst wordLength = word.length;\n\t// Consider only words of four letters or more to be past forms (otherwise, words like \"red\" are being treated as verb forms).\n\tif ( wordLength > 3 ) {\n\t\treturn word.substring( word.length - 2, word.length ) === \"ed\";\n\t}\n\treturn false;\n};\n\n/**\n * Forms the infinitive from an input word.\n *\n * @param {string} word The word to build the infinitive for.\n * @param {Array} sFormToInfinitiveRegex The array of regex-based rules used to bring -s forms to infinitive.\n * @param {Array} ingFormToInfinitiveRegex The array of regex-based rules used to bring -ing forms to infinitive.\n * @param {Array} edFormToInfinitiveRegex The array of regex-based rules used to bring -ed forms to infinitive.\n *\n * @returns {string} The infinitive of the input word.\n */\nconst getInfinitive = function( word, sFormToInfinitiveRegex, ingFormToInfinitiveRegex, edFormToInfinitiveRegex ) {\n\tif ( endsWithS( word ) ) {\n\t\treturn {\n\t\t\tinfinitive: buildOneFormFromRegex( word, sFormToInfinitiveRegex ),\n\t\t\tguessedForm: \"s\",\n\t\t};\n\t}\n\n\tif ( endsWithIng( word ) ) {\n\t\treturn {\n\t\t\tinfinitive: buildOneFormFromRegex( word, ingFormToInfinitiveRegex ),\n\t\t\tguessedForm: \"ing\",\n\t\t};\n\t}\n\n\tif ( endsWithEd( word ) ) {\n\t\treturn {\n\t\t\tinfinitive: buildOneFormFromRegex( word, edFormToInfinitiveRegex ),\n\t\t\tguessedForm: \"ed\",\n\t\t};\n\t}\n\treturn {\n\t\tinfinitive: word,\n\t\tguessedForm: \"inf\",\n\t};\n};\n\n/**\n * Collects all possible verb forms for a given word through checking if it is irregular, infinitive, s-form, ing-form or ed-form.\n *\n * @param {string} word The word for which to determine its forms.\n * @param {Object} verbsData The verb morphology data available for this language.\n *\n * @returns {Array} Array of word forms.\n */\nconst getVerbForms = function( word, verbsData ) {\n\tconst regexVerb = verbsData.regexVerb;\n\n\tconst irregular = checkIrregulars( word, verbsData.irregularVerbs, regexVerb.verbPrefixes );\n\tif ( ! isUndefined( irregular ) ) {\n\t\treturn irregular;\n\t}\n\n\tlet forms = [];\n\n\tconst sFormToInfinitiveRegex = createRulesFromMorphologyData( regexVerb.sFormToInfinitive );\n\tconst ingFormToInfinitiveRegex = createRulesFromMorphologyData( regexVerb.ingFormToInfinitive );\n\tconst edFormToInfinitiveRegex = createRulesFromMorphologyData( regexVerb.edFormToInfinitive );\n\n\tlet infinitive = getInfinitive( word, sFormToInfinitiveRegex, ingFormToInfinitiveRegex, edFormToInfinitiveRegex ).infinitive;\n\n\tif ( isUndefined( infinitive ) ) {\n\t\tinfinitive = word;\n\t}\n\n\t// Const guessedForm = getInfinitive( word ).guessedForm; //Meant to be used to check if the newly built forms are built correctly.\n\tforms = forms.concat( word );\n\n\tforms.push( infinitive );\n\tforms.push( buildOneFormFromRegex( infinitive, createRulesFromMorphologyData( regexVerb.infinitiveToSForm ) ) );\n\tforms.push( buildOneFormFromRegex( infinitive, createRulesFromMorphologyData( regexVerb.infinitiveToIngForm ) ) );\n\tforms.push( buildOneFormFromRegex( infinitive, createRulesFromMorphologyData( regexVerb.infinitiveToEdForm ) ) );\n\n\tforms = forms.filter( Boolean );\n\n\treturn unique( flatten( forms ) );\n};\n\nexport {\n\tgetVerbForms,\n\tnormalizePrefixed,\n};\n"]}