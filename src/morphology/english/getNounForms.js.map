{"version":3,"sources":["../../../../src/morphology/english/getNounForms.js"],"names":["checkPossessive","word","possessiveToBaseRegexes","i","length","reg","test","checkIrregulars","irregularNouns","irregulars","forEach","paradigm","wordInParadigm","getNounForms","nounData","forms","concat","base","regexNoun","baseIfPossessive","possessiveToBase","irregular","hispanic","push","singular","singularize","plural","pluralize","getNounFormsWithPossessives","map","form","baseToPossessive","filter","Boolean"],"mappings":"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","file":"getNounForms.js","sourcesContent":["// \"use strict\";\nimport createRulesFromMorphologyData from \"../morphoHelpers/createRulesFromMorphologyData.js\";\nimport { buildOneFormFromRegex, buildTwoFormsFromRegex } from \"../morphoHelpers/buildFormRule\";\n\nimport { isUndefined } from \"lodash-es\";\nimport { uniq as unique } from \"lodash-es\";\nimport { flatten } from \"lodash-es\";\n\n/**\n * Checks if the input word is a possessive form (e.g., \"boy's\" in \"the boy's car\") and returns true if that is the case.\n *\n * @param {string} word The word for which to determine if it's a possessive.\n * @param {Array} possessiveToBaseRegexes An array of regex-based rules to bring possessives to base.\n *\n * @returns {boolean} Whether the input word is a possessive form or not.\n */\nconst checkPossessive = function( word, possessiveToBaseRegexes ) {\n\tfor ( let i = 0; i < possessiveToBaseRegexes.length; i++ ) {\n\t\tif ( possessiveToBaseRegexes[ i ].reg.test( word ) ) {\n\t\t\treturn true;\n\t\t}\n\t}\n};\n\n/**\n * Checks if the input word occurs in the list of exception nouns and if so returns all its irregular forms.\n *\n * @param {string} word The word for which to determine its irregular forms.\n * @param {Array} irregularNouns An array of irregular nouns from the morphology data available for the language.\n *\n * @returns {Array} Array of word forms from the exception list.\n */\nconst checkIrregulars = function( word, irregularNouns ) {\n\tlet irregulars;\n\n\tirregularNouns.forEach( function( paradigm ) {\n\t\tparadigm.forEach( function( wordInParadigm ) {\n\t\t\tif ( wordInParadigm === word ) {\n\t\t\t\tirregulars = paradigm;\n\t\t\t}\n\t\t} );\n\t} );\n\treturn irregulars;\n};\n\n/**\n * Collects all possible noun forms for a given word through checking if it is irregular, hispanic, singular or plural.\n *\n * @param {string} word The word for which to determine its forms.\n * @param {Object} nounData The noun morphology data available for this language.\n *\n * @returns {Array} Array of word forms.\n */\nconst getNounForms = function( word, nounData ) {\n\tlet forms = [].concat( word );\n\tlet base = word;\n\n\tconst regexNoun = nounData.regexNoun;\n\n\tconst baseIfPossessive = buildOneFormFromRegex( word, createRulesFromMorphologyData( regexNoun.possessiveToBase ) );\n\tif ( ! isUndefined( baseIfPossessive ) ) {\n\t\tbase = baseIfPossessive;\n\t\tforms = forms.concat( base );\n\t}\n\n\tconst irregular = checkIrregulars( base, nounData.irregularNouns );\n\tif ( ! isUndefined( irregular ) ) {\n\t\treturn irregular;\n\t}\n\n\tconst hispanic = buildTwoFormsFromRegex( base, createRulesFromMorphologyData( regexNoun.hispanic ) );\n\tif ( ! isUndefined( hispanic ) ) {\n\t\tforms.push( hispanic[ 0 ], hispanic[ 1 ] );\n\t\treturn forms;\n\t}\n\n\tconst singular = buildOneFormFromRegex( base, createRulesFromMorphologyData( regexNoun.singularize ) );\n\tif ( ! isUndefined( singular ) ) {\n\t\tforms.push( singular );\n\t}\n\n\tconst plural = buildOneFormFromRegex( base, createRulesFromMorphologyData( regexNoun.pluralize ) );\n\tif ( ! isUndefined( plural ) ) {\n\t\tforms.push( plural );\n\t}\n\n\treturn unique( forms );\n};\n\n/**\n * Collects all possible noun forms for a given word through checking if it is irregular, hispanic, or regular.\n * Returns the irregular paradigm, singular, and plural, and possessive forms for all these.\n *\n * @param {string} word The word to collect all forms for.\n * @param {Object} nounData The noun morphology data available for this language.\n *\n * @returns {Array} Array of all word forms including possessives.\n */\nconst getNounFormsWithPossessives = function( word, nounData ) {\n\tlet forms = getNounForms( word, nounData );\n\n\t/* For every form in the forms array check if it is already a possessive or not.\n\t * If so, return nothing; if not, return a corresponding possessive form.\n\t * Because returning nothing generates undefined objects, filter(Boolean) to get rid of them.\n\t */\n\tforms = forms.concat( forms.map( function( form ) {\n\t\tif ( ! checkPossessive( form, createRulesFromMorphologyData( nounData.regexNoun.possessiveToBase ) ) ) {\n\t\t\treturn ( buildTwoFormsFromRegex( form, createRulesFromMorphologyData( nounData.regexNoun.baseToPossessive ) ) );\n\t\t}\n\t} ) ).filter( Boolean );\n\treturn unique( flatten( forms ) );\n};\n\nexport {\n\tgetNounFormsWithPossessives,\n\tgetNounForms,\n\tcheckPossessive,\n};\n"]}