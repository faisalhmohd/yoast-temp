{"version":3,"sources":["../../../../src/morphology/english/getAdjectiveForms.js"],"names":["checkIrregulars","word","irregularAdjectives","irregulars","forEach","paradigm","wordInParadigm","checkWordTooLong","endsWithEr","wordLength","length","substring","endsWithEst","endsWithLy","getBase","comparativeToBaseRegex","superlativeToBaseRegex","adverbToBaseRegex","base","guessedForm","getAdjectiveForms","adjectiveData","irregular","forms","regexAdjective","ically","icallyAdverbs","concat","comparativeToBase","superlativeToBase","adverbToBase","push","adverb","noComparativeOrSuperlative","RegExp","test","filter","Boolean","comparative","superlative"],"mappings":"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","file":"getAdjectiveForms.js","sourcesContent":["// \"use strict\";\nimport countSyllablesInText from \"../../stringProcessing/syllables/count\";\nimport createRulesFromMorphologyData from \"../morphoHelpers/createRulesFromMorphologyData.js\";\nimport { buildOneFormFromRegex, buildTwoFormsFromRegex } from \"../morphoHelpers/buildFormRule\";\n\nimport { isUndefined } from \"lodash-es\";\nimport { uniq as unique } from \"lodash-es\";\nimport { flatten } from \"lodash-es\";\n\n/**\n * Checks if the input word occurs in the list of irregular adjectives and if so returns all its irregular forms.\n *\n * @param {string} word The word for which to determine its irregular forms.\n * @param {Array} irregularAdjectives The list of irregular adjectives.\n *\n * @returns {Array} Array of word forms from the exception list.\n */\nconst checkIrregulars = function( word, irregularAdjectives ) {\n\tlet irregulars;\n\n\tirregularAdjectives.forEach( function( paradigm ) {\n\t\tparadigm.forEach( function( wordInParadigm ) {\n\t\t\tif ( wordInParadigm === word ) {\n\t\t\t\tirregulars = paradigm;\n\t\t\t}\n\t\t} );\n\t} );\n\treturn irregulars;\n};\n\n/**\n * Checks if the input word is longer than 2 syllables (in this case comparative and superlative forms do not need to be formed).\n *\n * @param {string} word The word for which to determine its length.\n *\n * @returns {boolean} True if the input word is longer than 2 syllables.\n */\nconst checkWordTooLong = function( word ) {\n\treturn countSyllablesInText( word, \"en_EN\" ) > 2;\n};\n\n/**\n * Checks if the input word ends with \"er\".\n *\n * @param {string} word The word to check.\n *\n * @returns {boolean} True if the word ends with \"er\".\n */\nconst endsWithEr = function( word ) {\n\tconst wordLength = word.length;\n\t// Consider only words of four letters or more to be comparatives (otherwise, words like \"per\" are being treated as comparatives).\n\tif ( wordLength > 3 ) {\n\t\treturn word.substring( word.length - 2, word.length ) === \"er\";\n\t}\n\treturn false;\n};\n\n/**\n * Checks if the input word ends with \"est\".\n *\n * @param {string} word The word to check.\n *\n * @returns {boolean} True if the word ends with \"est\".\n */\nconst endsWithEst = function( word ) {\n\tconst wordLength = word.length;\n\t// Consider only words of five letters or more to be superlatives (otherwise, words like \"test\" are being treated as superlatives).\n\tif ( wordLength > 4 ) {\n\t\treturn word.substring( word.length - 3, word.length ) === \"est\";\n\t}\n\treturn false;\n};\n\n/**\n * Checks if the input word ends with \"ly\".\n *\n * @param {string} word The word to check.\n *\n * @returns {boolean} True if the word ends with \"ly\".\n */\nconst endsWithLy = function( word ) {\n\tconst wordLength = word.length;\n\t// Consider only words of four letters or more to be adjectives (otherwise, words like \"lily\" are being treated as adjectives).\n\tif ( wordLength > 3 ) {\n\t\treturn word.substring( word.length - 2, word.length ) === \"ly\";\n\t}\n\treturn false;\n};\n\n\n/**\n * Forms the base form from an input word.\n *\n * @param {string} word The word to build the base form for.\n * @param {Array} comparativeToBaseRegex The Array of regex-based rules to bring comparatives to base.\n * @param {Array} superlativeToBaseRegex The Array of regex-based rules to bring superlatives to base.\n * @param {Array} adverbToBaseRegex The Array of regex-based rules to bring adverbs to base.\n *\n * @returns {string} The base form of the input word.\n */\nconst getBase = function( word, comparativeToBaseRegex, superlativeToBaseRegex, adverbToBaseRegex ) {\n\tif ( endsWithEr( word ) ) {\n\t\treturn {\n\t\t\tbase: buildOneFormFromRegex( word, comparativeToBaseRegex ),\n\t\t\tguessedForm: \"er\",\n\t\t};\n\t}\n\n\tif ( endsWithEst( word ) ) {\n\t\treturn {\n\t\t\tbase: buildOneFormFromRegex( word, superlativeToBaseRegex ),\n\t\t\tguessedForm: \"est\",\n\t\t};\n\t}\n\n\tif ( endsWithLy( word ) ) {\n\t\treturn {\n\t\t\tbase: buildOneFormFromRegex( word, adverbToBaseRegex ),\n\t\t\tguessedForm: \"ly\",\n\t\t};\n\t}\n\n\treturn {\n\t\tbase: word,\n\t\tguessedForm: \"base\",\n\t};\n};\n\n/**\n * Collects all possible verb forms for a given word through checking if it is irregular, base, adverb,\n * adverb ending in -ically, comparative, or superlative.\n *\n * @param {string} word The word for which to determine its forms.\n * @param {Object} adjectiveData The morphologyData available for this language.\n *\n * @returns {Array} Array of word forms.\n */\nconst getAdjectiveForms = function( word, adjectiveData ) {\n\tconst irregular = checkIrregulars( word, adjectiveData.irregularAdjectives );\n\tif ( ! isUndefined( irregular ) ) {\n\t\treturn irregular;\n\t}\n\n\tlet forms = [];\n\n\tconst regexAdjective = adjectiveData.regexAdjective;\n\tconst ically = buildTwoFormsFromRegex( word, createRulesFromMorphologyData( regexAdjective.icallyAdverbs ) );\n\tif ( ! isUndefined( ically ) ) {\n\t\treturn ically.concat( word );\n\t}\n\n\tconst comparativeToBaseRegex = createRulesFromMorphologyData( regexAdjective.comparativeToBase );\n\tconst superlativeToBaseRegex = createRulesFromMorphologyData( regexAdjective.superlativeToBase );\n\tconst adverbToBaseRegex = createRulesFromMorphologyData( regexAdjective.adverbToBase );\n\n\tlet base = getBase( word, comparativeToBaseRegex, superlativeToBaseRegex, adverbToBaseRegex ).base;\n\n\tif ( isUndefined( base ) ) {\n\t\tbase = word;\n\t}\n\n\t// Const guessedForm = getBase( word ).guessedForm; //Meant to be used to check if the newly built forms are built correctly.\n\tforms = forms.concat( word );\n\n\tforms.push( base );\n\tforms.push( buildOneFormFromRegex( base, createRulesFromMorphologyData( regexAdjective.adverb ) ) );\n\n\tconst noComparativeOrSuperlative = new RegExp( regexAdjective.noComparativeOrSuperlative, \"i\" );\n\tif ( checkWordTooLong( base ) === true || noComparativeOrSuperlative.test( base ) === true ) {\n\t\treturn unique( forms.filter( Boolean ) );\n\t}\n\n\tforms.push( buildOneFormFromRegex( base, createRulesFromMorphologyData( regexAdjective.comparative ) ) );\n\tforms.push( buildOneFormFromRegex( base, createRulesFromMorphologyData( regexAdjective.superlative ) ) );\n\n\treturn unique( flatten( forms.filter( Boolean ) ) );\n};\n\nexport {\n\tgetAdjectiveForms,\n\tgetBase,\n};\n"]}